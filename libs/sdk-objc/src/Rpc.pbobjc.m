// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Rpc.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "Rpc.pbobjc.h"
 #import "Peer.pbobjc.h"
 #import "Cryptography.pbobjc.h"
 #import "Deltas.pbobjc.h"
 #import "Wire.pbobjc.h"
 #import "Transaction.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - RpcRoot

@implementation RpcRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - RpcRoot_FileDescriptor

static GPBFileDescriptor *RpcRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Catalyst.Protocol.Rpc.Node"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum ResponseCode

GPBEnumDescriptor *ResponseCode_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "Pending\000Successful\000Error\000Finished\000Expire"
        "d\000Failed\000";
    static const int32_t values[] = {
        ResponseCode_Pending,
        ResponseCode_Successful,
        ResponseCode_Error,
        ResponseCode_Finished,
        ResponseCode_Expired,
        ResponseCode_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ResponseCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ResponseCode_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ResponseCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ResponseCode_Pending:
    case ResponseCode_Successful:
    case ResponseCode_Error:
    case ResponseCode_Finished:
    case ResponseCode_Expired:
    case ResponseCode_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - VersionRequest

@implementation VersionRequest

@dynamic query;

typedef struct VersionRequest__storage_ {
  uint32_t _has_storage_[1];
} VersionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = VersionRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VersionResponse

@implementation VersionResponse

@dynamic version;

typedef struct VersionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *version;
} VersionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = VersionResponse_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VersionResponse__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VersionResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VersionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoRequest

@implementation GetInfoRequest

@dynamic query;

typedef struct GetInfoRequest__storage_ {
  uint32_t _has_storage_[1];
} GetInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetInfoResponse

@implementation GetInfoResponse

@dynamic query;

typedef struct GetInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} GetInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetInfoResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetInfoResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateWalletRequest

@implementation CreateWalletRequest

@dynamic query;

typedef struct CreateWalletRequest__storage_ {
  uint32_t _has_storage_[1];
} CreateWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateWalletRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateWalletResponse

@implementation CreateWalletResponse

@dynamic query;

typedef struct CreateWalletResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} CreateWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateWalletResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateWalletResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListWalletRequest

@implementation ListWalletRequest

@dynamic query;

typedef struct ListWalletRequest__storage_ {
  uint32_t _has_storage_[1];
} ListWalletRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ListWalletRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListWalletRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListWalletRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListWalletResponse

@implementation ListWalletResponse

@dynamic query;

typedef struct ListWalletResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} ListWalletResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ListWalletResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListWalletResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListWalletResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListWalletResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAddressRequest

@implementation CreateAddressRequest

@dynamic query;

typedef struct CreateAddressRequest__storage_ {
  uint32_t _has_storage_[1];
} CreateAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateAddressRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateAddressResponse

@implementation CreateAddressResponse

@dynamic query;

typedef struct CreateAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} CreateAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateAddressResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateAddressResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressRequest

@implementation GetAddressRequest

@dynamic query;

typedef struct GetAddressRequest__storage_ {
  uint32_t _has_storage_[1];
} GetAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetAddressResponse

@implementation GetAddressResponse

@dynamic query;

typedef struct GetAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} GetAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetAddressResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetAddressResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListAddressRequest

@implementation ListAddressRequest

@dynamic query;

typedef struct ListAddressRequest__storage_ {
  uint32_t _has_storage_[1];
} ListAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ListAddressRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ListAddressResponse

@implementation ListAddressResponse

@dynamic query;

typedef struct ListAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} ListAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ListAddressResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ListAddressResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ListAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ListAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidateAddressRequest

@implementation ValidateAddressRequest

@dynamic query;

typedef struct ValidateAddressRequest__storage_ {
  uint32_t _has_storage_[1];
} ValidateAddressRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ValidateAddressRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ValidateAddressRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidateAddressRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ValidateAddressResponse

@implementation ValidateAddressResponse

@dynamic query;

typedef struct ValidateAddressResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} ValidateAddressResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ValidateAddressResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ValidateAddressResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ValidateAddressResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ValidateAddressResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBalanceRequest

@implementation GetBalanceRequest

@dynamic query;

typedef struct GetBalanceRequest__storage_ {
  uint32_t _has_storage_[1];
} GetBalanceRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetBalanceRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBalanceRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBalanceRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetBalanceResponse

@implementation GetBalanceResponse

@dynamic query;

typedef struct GetBalanceResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} GetBalanceResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetBalanceResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetBalanceResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetBalanceResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetBalanceResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateRawTransactionRequest

@implementation CreateRawTransactionRequest

@dynamic query;

typedef struct CreateRawTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
} CreateRawTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateRawTransactionRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRawTransactionRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRawTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CreateRawTransactionResponse

@implementation CreateRawTransactionResponse

@dynamic query;

typedef struct CreateRawTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} CreateRawTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = CreateRawTransactionResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CreateRawTransactionResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CreateRawTransactionResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CreateRawTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignRawTransactionRequest

@implementation SignRawTransactionRequest

@dynamic query;

typedef struct SignRawTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
} SignRawTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SignRawTransactionRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignRawTransactionRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignRawTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignRawTransactionResponse

@implementation SignRawTransactionResponse

@dynamic query;

typedef struct SignRawTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SignRawTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SignRawTransactionResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignRawTransactionResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignRawTransactionResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignRawTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecodeRawTransactionRequest

@implementation DecodeRawTransactionRequest

@dynamic query;

typedef struct DecodeRawTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
} DecodeRawTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = DecodeRawTransactionRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecodeRawTransactionRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecodeRawTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DecodeRawTransactionResponse

@implementation DecodeRawTransactionResponse

@dynamic query;

typedef struct DecodeRawTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} DecodeRawTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = DecodeRawTransactionResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DecodeRawTransactionResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DecodeRawTransactionResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DecodeRawTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastRawTransactionRequest

@implementation BroadcastRawTransactionRequest

@dynamic hasTransaction, transaction;

typedef struct BroadcastRawTransactionRequest__storage_ {
  uint32_t _has_storage_[1];
  TransactionBroadcast *transaction;
} BroadcastRawTransactionRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionBroadcast),
        .number = BroadcastRawTransactionRequest_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastRawTransactionRequest__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastRawTransactionRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastRawTransactionRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BroadcastRawTransactionResponse

@implementation BroadcastRawTransactionResponse

@dynamic responseCode;

typedef struct BroadcastRawTransactionResponse__storage_ {
  uint32_t _has_storage_[1];
  ResponseCode responseCode;
} BroadcastRawTransactionResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseCode",
        .dataTypeSpecific.enumDescFunc = ResponseCode_EnumDescriptor,
        .number = BroadcastRawTransactionResponse_FieldNumber_ResponseCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BroadcastRawTransactionResponse__storage_, responseCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BroadcastRawTransactionResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BroadcastRawTransactionResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BroadcastRawTransactionResponse_ResponseCode_RawValue(BroadcastRawTransactionResponse *message) {
  GPBDescriptor *descriptor = [BroadcastRawTransactionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BroadcastRawTransactionResponse_FieldNumber_ResponseCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetBroadcastRawTransactionResponse_ResponseCode_RawValue(BroadcastRawTransactionResponse *message, int32_t value) {
  GPBDescriptor *descriptor = [BroadcastRawTransactionResponse descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BroadcastRawTransactionResponse_FieldNumber_ResponseCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - SendToRequest

@implementation SendToRequest

@dynamic query;

typedef struct SendToRequest__storage_ {
  uint32_t _has_storage_[1];
} SendToRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendToRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendToResponse

@implementation SendToResponse

@dynamic query;

typedef struct SendToResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SendToResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendToResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendToResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendToFromRequest

@implementation SendToFromRequest

@dynamic query;

typedef struct SendToFromRequest__storage_ {
  uint32_t _has_storage_[1];
} SendToFromRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendToFromRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToFromRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToFromRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendToFromResponse

@implementation SendToFromResponse

@dynamic query;

typedef struct SendToFromResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SendToFromResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendToFromResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendToFromResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendToFromResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendToFromResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyRequest

@implementation SendManyRequest

@dynamic query;

typedef struct SendManyRequest__storage_ {
  uint32_t _has_storage_[1];
} SendManyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendManyRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendManyResponse

@implementation SendManyResponse

@dynamic query;

typedef struct SendManyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SendManyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendManyResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendManyResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendManyResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendManyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendFromManyRequest

@implementation SendFromManyRequest

@dynamic query;

typedef struct SendFromManyRequest__storage_ {
  uint32_t _has_storage_[1];
} SendFromManyRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendFromManyRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendFromManyRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendFromManyRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SendFromManyResponse

@implementation SendFromManyResponse

@dynamic query;

typedef struct SendFromManyResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} SendFromManyResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SendFromManyResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SendFromManyResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SendFromManyResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SendFromManyResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodeRequest

@implementation AddNodeRequest

@dynamic query;

typedef struct AddNodeRequest__storage_ {
  uint32_t _has_storage_[1];
} AddNodeRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = AddNodeRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodeRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddNodeRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddNodeResponse

@implementation AddNodeResponse

@dynamic query;

typedef struct AddNodeResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} AddNodeResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = AddNodeResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddNodeResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddNodeResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddNodeResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerListRequest

@implementation GetPeerListRequest


typedef struct GetPeerListRequest__storage_ {
  uint32_t _has_storage_[1];
} GetPeerListRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerListRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetPeerListRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerListResponse

@implementation GetPeerListResponse

@dynamic peersArray, peersArray_Count;

typedef struct GetPeerListResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peersArray;
} GetPeerListResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerId),
        .number = GetPeerListResponse_FieldNumber_PeersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPeerListResponse__storage_, peersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerListResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerListResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerReputationRequest

@implementation GetPeerReputationRequest

@dynamic publicKey;
@dynamic ip;

typedef struct GetPeerReputationRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKey;
  NSData *ip;
} GetPeerReputationRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerReputationRequest_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPeerReputationRequest__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerReputationRequest_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPeerReputationRequest__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerReputationRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerReputationRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerReputationResponse

@implementation GetPeerReputationResponse

@dynamic reputation;

typedef struct GetPeerReputationResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t reputation;
} GetPeerReputationResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reputation",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerReputationResponse_FieldNumber_Reputation,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPeerReputationResponse__storage_, reputation),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerReputationResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerReputationResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPeerBlacklistRequest

@implementation SetPeerBlacklistRequest

@dynamic publicKey;
@dynamic ip;
@dynamic blacklist;

typedef struct SetPeerBlacklistRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKey;
  NSData *ip;
} SetPeerBlacklistRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistRequest_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPeerBlacklistRequest__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistRequest_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetPeerBlacklistRequest__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistRequest_FieldNumber_Blacklist,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPeerBlacklistRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPeerBlacklistRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPeerBlacklistResponse

@implementation SetPeerBlacklistResponse

@dynamic publicKey;
@dynamic ip;
@dynamic blacklist;

typedef struct SetPeerBlacklistResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKey;
  NSData *ip;
} SetPeerBlacklistResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistResponse_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPeerBlacklistResponse__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistResponse_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetPeerBlacklistResponse__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "blacklist",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerBlacklistResponse_FieldNumber_Blacklist,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPeerBlacklistResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPeerBlacklistResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerInfoRequest

@implementation GetPeerInfoRequest

@dynamic publicKey;
@dynamic ip;

typedef struct GetPeerInfoRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *publicKey;
  NSData *ip;
} GetPeerInfoRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerInfoRequest_FieldNumber_PublicKey,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPeerInfoRequest__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ip",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerInfoRequest_FieldNumber_Ip,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetPeerInfoRequest__storage_, ip),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerInfoRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerInfoRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerInfoResponse

@implementation GetPeerInfoResponse

@dynamic peerInfoArray, peerInfoArray_Count;

typedef struct GetPeerInfoResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *peerInfoArray;
} GetPeerInfoResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerInfo),
        .number = GetPeerInfoResponse_FieldNumber_PeerInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetPeerInfoResponse__storage_, peerInfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerInfoResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerInfoResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConnectionCountRequest

@implementation GetConnectionCountRequest

@dynamic query;

typedef struct GetConnectionCountRequest__storage_ {
  uint32_t _has_storage_[1];
} GetConnectionCountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectionCountRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConnectionCountRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConnectionCountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetConnectionCountResponse

@implementation GetConnectionCountResponse

@dynamic query;

typedef struct GetConnectionCountResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} GetConnectionCountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetConnectionCountResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetConnectionCountResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetConnectionCountResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetConnectionCountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDeltaRequest

@implementation GetDeltaRequest

@dynamic deltaDfsHash;

typedef struct GetDeltaRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *deltaDfsHash;
} GetDeltaRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deltaDfsHash",
        .dataTypeSpecific.className = NULL,
        .number = GetDeltaRequest_FieldNumber_DeltaDfsHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDeltaRequest__storage_, deltaDfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDeltaRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDeltaRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDeltaResponse

@implementation GetDeltaResponse

@dynamic hasDelta, delta;

typedef struct GetDeltaResponse__storage_ {
  uint32_t _has_storage_[1];
  Delta *delta;
} GetDeltaResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "delta",
        .dataTypeSpecific.className = GPBStringifySymbol(Delta),
        .number = GetDeltaResponse_FieldNumber_Delta,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetDeltaResponse__storage_, delta),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDeltaResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetDeltaResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolRequest

@implementation GetMempoolRequest

@dynamic query;

typedef struct GetMempoolRequest__storage_ {
  uint32_t _has_storage_[1];
} GetMempoolRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = GetMempoolRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetMempoolResponse

@implementation GetMempoolResponse

@dynamic transactionsArray, transactionsArray_Count;

typedef struct GetMempoolResponse__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} GetMempoolResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(PublicEntry),
        .number = GetMempoolResponse_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(GetMempoolResponse__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetMempoolResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetMempoolResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageRequest

@implementation SignMessageRequest

@dynamic message;
@dynamic keyId;
@dynamic hasSigningContext, signingContext;

typedef struct SignMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *message;
  NSString *keyId;
  SigningContext *signingContext;
} SignMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageRequest_FieldNumber_Message,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keyId",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageRequest_FieldNumber_KeyId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignMessageRequest__storage_, keyId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signingContext",
        .dataTypeSpecific.className = GPBStringifySymbol(SigningContext),
        .number = SignMessageRequest_FieldNumber_SigningContext,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignMessageRequest__storage_, signingContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SignMessageResponse

@implementation SignMessageResponse

@dynamic signature;
@dynamic publicKey;
@dynamic originalMessage;

typedef struct SignMessageResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSData *publicKey;
  NSData *originalMessage;
} SignMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageResponse_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SignMessageResponse__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageResponse_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SignMessageResponse__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "originalMessage",
        .dataTypeSpecific.className = NULL,
        .number = SignMessageResponse_FieldNumber_OriginalMessage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SignMessageResponse__storage_, originalMessage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SignMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SignMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageRequest

@implementation VerifyMessageRequest

@dynamic signature;
@dynamic publicKey;
@dynamic message;
@dynamic hasSigningContext, signingContext;

typedef struct VerifyMessageRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *signature;
  NSData *publicKey;
  NSData *message;
  SigningContext *signingContext;
} VerifyMessageRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "message",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageRequest_FieldNumber_Message,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, message),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signingContext",
        .dataTypeSpecific.className = GPBStringifySymbol(SigningContext),
        .number = VerifyMessageRequest_FieldNumber_SigningContext,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(VerifyMessageRequest__storage_, signingContext),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - VerifyMessageResponse

@implementation VerifyMessageResponse

@dynamic isSignedByKey;

typedef struct VerifyMessageResponse__storage_ {
  uint32_t _has_storage_[1];
} VerifyMessageResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "isSignedByKey",
        .dataTypeSpecific.className = NULL,
        .number = VerifyMessageResponse_FieldNumber_IsSignedByKey,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[VerifyMessageResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(VerifyMessageResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceStatusRequest

@implementation ServiceStatusRequest

@dynamic query;

typedef struct ServiceStatusRequest__storage_ {
  uint32_t _has_storage_[1];
} ServiceStatusRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ServiceStatusRequest_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceStatusRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceStatusRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ServiceStatusResponse

@implementation ServiceStatusResponse

@dynamic query;

typedef struct ServiceStatusResponse__storage_ {
  uint32_t _has_storage_[1];
  NSString *query;
} ServiceStatusResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = ServiceStatusResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ServiceStatusResponse__storage_, query),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ServiceStatusResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ServiceStatusResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFileToDfsRequest

@implementation AddFileToDfsRequest

@dynamic fileSize;
@dynamic fileName;
@dynamic node;

typedef struct AddFileToDfsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *fileName;
  NSString *node;
  uint64_t fileSize;
} AddFileToDfsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = AddFileToDfsRequest_FieldNumber_FileSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFileToDfsRequest__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "fileName",
        .dataTypeSpecific.className = NULL,
        .number = AddFileToDfsRequest_FieldNumber_FileName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFileToDfsRequest__storage_, fileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "node",
        .dataTypeSpecific.className = NULL,
        .number = AddFileToDfsRequest_FieldNumber_Node,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(AddFileToDfsRequest__storage_, node),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFileToDfsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFileToDfsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - AddFileToDfsResponse

@implementation AddFileToDfsResponse

@dynamic responseCode;
@dynamic dfsHash;

typedef struct AddFileToDfsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *responseCode;
  NSString *dfsHash;
} AddFileToDfsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseCode",
        .dataTypeSpecific.className = NULL,
        .number = AddFileToDfsResponse_FieldNumber_ResponseCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AddFileToDfsResponse__storage_, responseCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "dfsHash",
        .dataTypeSpecific.className = NULL,
        .number = AddFileToDfsResponse_FieldNumber_DfsHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AddFileToDfsResponse__storage_, dfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AddFileToDfsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AddFileToDfsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferFileBytesRequest

@implementation TransferFileBytesRequest

@dynamic chunkId;
@dynamic chunkBytes;
@dynamic correlationFileName;

typedef struct TransferFileBytesRequest__storage_ {
  uint32_t _has_storage_[1];
  uint32_t chunkId;
  NSData *chunkBytes;
  NSData *correlationFileName;
} TransferFileBytesRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chunkId",
        .dataTypeSpecific.className = NULL,
        .number = TransferFileBytesRequest_FieldNumber_ChunkId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferFileBytesRequest__storage_, chunkId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "chunkBytes",
        .dataTypeSpecific.className = NULL,
        .number = TransferFileBytesRequest_FieldNumber_ChunkBytes,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransferFileBytesRequest__storage_, chunkBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "correlationFileName",
        .dataTypeSpecific.className = NULL,
        .number = TransferFileBytesRequest_FieldNumber_CorrelationFileName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransferFileBytesRequest__storage_, correlationFileName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferFileBytesRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferFileBytesRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransferFileBytesResponse

@implementation TransferFileBytesResponse

@dynamic responseCode;

typedef struct TransferFileBytesResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *responseCode;
} TransferFileBytesResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "responseCode",
        .dataTypeSpecific.className = NULL,
        .number = TransferFileBytesResponse_FieldNumber_ResponseCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransferFileBytesResponse__storage_, responseCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransferFileBytesResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransferFileBytesResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemovePeerRequest

@implementation RemovePeerRequest

@dynamic peerIp;
@dynamic publicKey;

typedef struct RemovePeerRequest__storage_ {
  uint32_t _has_storage_[1];
  NSData *peerIp;
  NSData *publicKey;
} RemovePeerRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerIp",
        .dataTypeSpecific.className = NULL,
        .number = RemovePeerRequest_FieldNumber_PeerIp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemovePeerRequest__storage_, peerIp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "publicKey",
        .dataTypeSpecific.className = NULL,
        .number = RemovePeerRequest_FieldNumber_PublicKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemovePeerRequest__storage_, publicKey),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemovePeerRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemovePeerRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemovePeerResponse

@implementation RemovePeerResponse

@dynamic deletedCount;

typedef struct RemovePeerResponse__storage_ {
  uint32_t _has_storage_[1];
  uint32_t deletedCount;
} RemovePeerResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deletedCount",
        .dataTypeSpecific.className = NULL,
        .number = RemovePeerResponse_FieldNumber_DeletedCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemovePeerResponse__storage_, deletedCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemovePeerResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemovePeerResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerCountRequest

@implementation GetPeerCountRequest


typedef struct GetPeerCountRequest__storage_ {
  uint32_t _has_storage_[1];
} GetPeerCountRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerCountRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetPeerCountRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetPeerCountResponse

@implementation GetPeerCountResponse

@dynamic peerCount;

typedef struct GetPeerCountResponse__storage_ {
  uint32_t _has_storage_[1];
  int32_t peerCount;
} GetPeerCountResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerCount",
        .dataTypeSpecific.className = NULL,
        .number = GetPeerCountResponse_FieldNumber_PeerCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetPeerCountResponse__storage_, peerCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetPeerCountResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetPeerCountResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFileFromDfsRequest

@implementation GetFileFromDfsRequest

@dynamic dfsHash;

typedef struct GetFileFromDfsRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *dfsHash;
} GetFileFromDfsRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dfsHash",
        .dataTypeSpecific.className = NULL,
        .number = GetFileFromDfsRequest_FieldNumber_DfsHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFileFromDfsRequest__storage_, dfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFileFromDfsRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFileFromDfsRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetFileFromDfsResponse

@implementation GetFileFromDfsResponse

@dynamic fileSize;
@dynamic responseCode;

typedef struct GetFileFromDfsResponse__storage_ {
  uint32_t _has_storage_[1];
  NSData *responseCode;
  uint64_t fileSize;
} GetFileFromDfsResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fileSize",
        .dataTypeSpecific.className = NULL,
        .number = GetFileFromDfsResponse_FieldNumber_FileSize,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetFileFromDfsResponse__storage_, fileSize),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "responseCode",
        .dataTypeSpecific.className = NULL,
        .number = GetFileFromDfsResponse_FieldNumber_ResponseCode,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(GetFileFromDfsResponse__storage_, responseCode),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetFileFromDfsResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetFileFromDfsResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPeerDataFolderRequest

@implementation SetPeerDataFolderRequest

@dynamic dataFolder;

typedef struct SetPeerDataFolderRequest__storage_ {
  uint32_t _has_storage_[1];
  NSString *dataFolder;
} SetPeerDataFolderRequest__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dataFolder",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerDataFolderRequest_FieldNumber_DataFolder,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetPeerDataFolderRequest__storage_, dataFolder),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPeerDataFolderRequest class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPeerDataFolderRequest__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetPeerDataFolderResponse

@implementation SetPeerDataFolderResponse

@dynamic query;

typedef struct SetPeerDataFolderResponse__storage_ {
  uint32_t _has_storage_[1];
} SetPeerDataFolderResponse__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "query",
        .dataTypeSpecific.className = NULL,
        .number = SetPeerDataFolderResponse_FieldNumber_Query,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetPeerDataFolderResponse class]
                                     rootClass:[RpcRoot class]
                                          file:RpcRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetPeerDataFolderResponse__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
