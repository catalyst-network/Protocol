// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Transaction.proto

#ifndef PROTOBUF_Transaction_2eproto__INCLUDED
#define PROTOBUF_Transaction_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3002000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3002000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "Cryptography.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
namespace Catalyst {
namespace Protocol {
namespace Cryptography {
class Signature;
class SignatureDefaultTypeInternal;
extern SignatureDefaultTypeInternal _Signature_default_instance_;
class SigningContext;
class SigningContextDefaultTypeInternal;
extern SigningContextDefaultTypeInternal _SigningContext_default_instance_;
}  // namespace Cryptography
namespace Transaction {
class BaseEntry;
class BaseEntryDefaultTypeInternal;
extern BaseEntryDefaultTypeInternal _BaseEntry_default_instance_;
class CoinbaseEntry;
class CoinbaseEntryDefaultTypeInternal;
extern CoinbaseEntryDefaultTypeInternal _CoinbaseEntry_default_instance_;
class ConfidentialEntry;
class ConfidentialEntryDefaultTypeInternal;
extern ConfidentialEntryDefaultTypeInternal _ConfidentialEntry_default_instance_;
class PublicEntry;
class PublicEntryDefaultTypeInternal;
extern PublicEntryDefaultTypeInternal _PublicEntry_default_instance_;
class RangeProof;
class RangeProofDefaultTypeInternal;
extern RangeProofDefaultTypeInternal _RangeProof_default_instance_;
}  // namespace Transaction
}  // namespace Protocol
}  // namespace Catalyst
namespace google {
namespace protobuf {
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google

namespace Catalyst {
namespace Protocol {
namespace Transaction {

namespace protobuf_Transaction_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_Transaction_2eproto

enum TransactionType {
  TRANSACTION_TYPE_UNKNOWN = 0,
  PUBLIC = 1,
  CONFIDENTIAL = 2,
  TransactionType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TransactionType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TransactionType_IsValid(int value);
const TransactionType TransactionType_MIN = TRANSACTION_TYPE_UNKNOWN;
const TransactionType TransactionType_MAX = CONFIDENTIAL;
const int TransactionType_ARRAYSIZE = TransactionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TransactionType_descriptor();
inline const ::std::string& TransactionType_Name(TransactionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TransactionType_descriptor(), value);
}
inline bool TransactionType_Parse(
    const ::std::string& name, TransactionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TransactionType>(
    TransactionType_descriptor(), name, value);
}
// ===================================================================

class PublicEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Catalyst.Protocol.Transaction.PublicEntry) */ {
 public:
  PublicEntry();
  virtual ~PublicEntry();

  PublicEntry(const PublicEntry& from);

  inline PublicEntry& operator=(const PublicEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicEntry& default_instance();

  static inline const PublicEntry* internal_default_instance() {
    return reinterpret_cast<const PublicEntry*>(
               &_PublicEntry_default_instance_);
  }

  void Swap(PublicEntry* other);

  // implements Message ----------------------------------------------

  inline PublicEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  PublicEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PublicEntry& from);
  void MergeFrom(const PublicEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PublicEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const void* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // bytes data = 3;
  void clear_data();
  static const int kDataFieldNumber = 3;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // bytes gas_price = 6;
  void clear_gas_price();
  static const int kGasPriceFieldNumber = 6;
  const ::std::string& gas_price() const;
  void set_gas_price(const ::std::string& value);
  #if LANG_CXX11
  void set_gas_price(::std::string&& value);
  #endif
  void set_gas_price(const char* value);
  void set_gas_price(const void* value, size_t size);
  ::std::string* mutable_gas_price();
  ::std::string* release_gas_price();
  void set_allocated_gas_price(::std::string* gas_price);

  // .Catalyst.Protocol.Transaction.BaseEntry base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::Catalyst::Protocol::Transaction::BaseEntry& base() const;
  ::Catalyst::Protocol::Transaction::BaseEntry* mutable_base();
  ::Catalyst::Protocol::Transaction::BaseEntry* release_base();
  void set_allocated_base(::Catalyst::Protocol::Transaction::BaseEntry* base);

  // .google.protobuf.Timestamp timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // .Catalyst.Protocol.Cryptography.Signature signature = 5;
  bool has_signature() const;
  void clear_signature();
  static const int kSignatureFieldNumber = 5;
  const ::Catalyst::Protocol::Cryptography::Signature& signature() const;
  ::Catalyst::Protocol::Cryptography::Signature* mutable_signature();
  ::Catalyst::Protocol::Cryptography::Signature* release_signature();
  void set_allocated_signature(::Catalyst::Protocol::Cryptography::Signature* signature);

  // uint64 gas_limit = 7;
  void clear_gas_limit();
  static const int kGasLimitFieldNumber = 7;
  ::google::protobuf::uint64 gas_limit() const;
  void set_gas_limit(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Catalyst.Protocol.Transaction.PublicEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::internal::ArenaStringPtr gas_price_;
  ::Catalyst::Protocol::Transaction::BaseEntry* base_;
  ::google::protobuf::Timestamp* timestamp_;
  ::Catalyst::Protocol::Cryptography::Signature* signature_;
  ::google::protobuf::uint64 gas_limit_;
  mutable int _cached_size_;
  friend struct  protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConfidentialEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Catalyst.Protocol.Transaction.ConfidentialEntry) */ {
 public:
  ConfidentialEntry();
  virtual ~ConfidentialEntry();

  ConfidentialEntry(const ConfidentialEntry& from);

  inline ConfidentialEntry& operator=(const ConfidentialEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfidentialEntry& default_instance();

  static inline const ConfidentialEntry* internal_default_instance() {
    return reinterpret_cast<const ConfidentialEntry*>(
               &_ConfidentialEntry_default_instance_);
  }

  void Swap(ConfidentialEntry* other);

  // implements Message ----------------------------------------------

  inline ConfidentialEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  ConfidentialEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConfidentialEntry& from);
  void MergeFrom(const ConfidentialEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConfidentialEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes pedersen_commitment = 2;
  void clear_pedersen_commitment();
  static const int kPedersenCommitmentFieldNumber = 2;
  const ::std::string& pedersen_commitment() const;
  void set_pedersen_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_pedersen_commitment(::std::string&& value);
  #endif
  void set_pedersen_commitment(const char* value);
  void set_pedersen_commitment(const void* value, size_t size);
  ::std::string* mutable_pedersen_commitment();
  ::std::string* release_pedersen_commitment();
  void set_allocated_pedersen_commitment(::std::string* pedersen_commitment);

  // .Catalyst.Protocol.Transaction.BaseEntry base = 1;
  bool has_base() const;
  void clear_base();
  static const int kBaseFieldNumber = 1;
  const ::Catalyst::Protocol::Transaction::BaseEntry& base() const;
  ::Catalyst::Protocol::Transaction::BaseEntry* mutable_base();
  ::Catalyst::Protocol::Transaction::BaseEntry* release_base();
  void set_allocated_base(::Catalyst::Protocol::Transaction::BaseEntry* base);

  // .Catalyst.Protocol.Transaction.RangeProof range_proof = 3;
  bool has_range_proof() const;
  void clear_range_proof();
  static const int kRangeProofFieldNumber = 3;
  const ::Catalyst::Protocol::Transaction::RangeProof& range_proof() const;
  ::Catalyst::Protocol::Transaction::RangeProof* mutable_range_proof();
  ::Catalyst::Protocol::Transaction::RangeProof* release_range_proof();
  void set_allocated_range_proof(::Catalyst::Protocol::Transaction::RangeProof* range_proof);

  // @@protoc_insertion_point(class_scope:Catalyst.Protocol.Transaction.ConfidentialEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pedersen_commitment_;
  ::Catalyst::Protocol::Transaction::BaseEntry* base_;
  ::Catalyst::Protocol::Transaction::RangeProof* range_proof_;
  mutable int _cached_size_;
  friend struct  protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BaseEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Catalyst.Protocol.Transaction.BaseEntry) */ {
 public:
  BaseEntry();
  virtual ~BaseEntry();

  BaseEntry(const BaseEntry& from);

  inline BaseEntry& operator=(const BaseEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BaseEntry& default_instance();

  static inline const BaseEntry* internal_default_instance() {
    return reinterpret_cast<const BaseEntry*>(
               &_BaseEntry_default_instance_);
  }

  void Swap(BaseEntry* other);

  // implements Message ----------------------------------------------

  inline BaseEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  BaseEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BaseEntry& from);
  void MergeFrom(const BaseEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BaseEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes receiver_public_key = 2;
  void clear_receiver_public_key();
  static const int kReceiverPublicKeyFieldNumber = 2;
  const ::std::string& receiver_public_key() const;
  void set_receiver_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver_public_key(::std::string&& value);
  #endif
  void set_receiver_public_key(const char* value);
  void set_receiver_public_key(const void* value, size_t size);
  ::std::string* mutable_receiver_public_key();
  ::std::string* release_receiver_public_key();
  void set_allocated_receiver_public_key(::std::string* receiver_public_key);

  // bytes sender_public_key = 3;
  void clear_sender_public_key();
  static const int kSenderPublicKeyFieldNumber = 3;
  const ::std::string& sender_public_key() const;
  void set_sender_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_sender_public_key(::std::string&& value);
  #endif
  void set_sender_public_key(const char* value);
  void set_sender_public_key(const void* value, size_t size);
  ::std::string* mutable_sender_public_key();
  ::std::string* release_sender_public_key();
  void set_allocated_sender_public_key(::std::string* sender_public_key);

  // bytes transaction_fees = 4;
  void clear_transaction_fees();
  static const int kTransactionFeesFieldNumber = 4;
  const ::std::string& transaction_fees() const;
  void set_transaction_fees(const ::std::string& value);
  #if LANG_CXX11
  void set_transaction_fees(::std::string&& value);
  #endif
  void set_transaction_fees(const char* value);
  void set_transaction_fees(const void* value, size_t size);
  ::std::string* mutable_transaction_fees();
  ::std::string* release_transaction_fees();
  void set_allocated_transaction_fees(::std::string* transaction_fees);

  // uint64 nonce = 1;
  void clear_nonce();
  static const int kNonceFieldNumber = 1;
  ::google::protobuf::uint64 nonce() const;
  void set_nonce(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Catalyst.Protocol.Transaction.BaseEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr receiver_public_key_;
  ::google::protobuf::internal::ArenaStringPtr sender_public_key_;
  ::google::protobuf::internal::ArenaStringPtr transaction_fees_;
  ::google::protobuf::uint64 nonce_;
  mutable int _cached_size_;
  friend struct  protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoinbaseEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Catalyst.Protocol.Transaction.CoinbaseEntry) */ {
 public:
  CoinbaseEntry();
  virtual ~CoinbaseEntry();

  CoinbaseEntry(const CoinbaseEntry& from);

  inline CoinbaseEntry& operator=(const CoinbaseEntry& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinbaseEntry& default_instance();

  static inline const CoinbaseEntry* internal_default_instance() {
    return reinterpret_cast<const CoinbaseEntry*>(
               &_CoinbaseEntry_default_instance_);
  }

  void Swap(CoinbaseEntry* other);

  // implements Message ----------------------------------------------

  inline CoinbaseEntry* New() const PROTOBUF_FINAL { return New(NULL); }

  CoinbaseEntry* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CoinbaseEntry& from);
  void MergeFrom(const CoinbaseEntry& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CoinbaseEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes receiver_public_key = 1;
  void clear_receiver_public_key();
  static const int kReceiverPublicKeyFieldNumber = 1;
  const ::std::string& receiver_public_key() const;
  void set_receiver_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_receiver_public_key(::std::string&& value);
  #endif
  void set_receiver_public_key(const char* value);
  void set_receiver_public_key(const void* value, size_t size);
  ::std::string* mutable_receiver_public_key();
  ::std::string* release_receiver_public_key();
  void set_allocated_receiver_public_key(::std::string* receiver_public_key);

  // bytes amount = 2;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  const ::std::string& amount() const;
  void set_amount(const ::std::string& value);
  #if LANG_CXX11
  void set_amount(::std::string&& value);
  #endif
  void set_amount(const char* value);
  void set_amount(const void* value, size_t size);
  ::std::string* mutable_amount();
  ::std::string* release_amount();
  void set_allocated_amount(::std::string* amount);

  // @@protoc_insertion_point(class_scope:Catalyst.Protocol.Transaction.CoinbaseEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr receiver_public_key_;
  ::google::protobuf::internal::ArenaStringPtr amount_;
  mutable int _cached_size_;
  friend struct  protobuf_Transaction_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RangeProof : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Catalyst.Protocol.Transaction.RangeProof) */ {
 public:
  RangeProof();
  virtual ~RangeProof();

  RangeProof(const RangeProof& from);

  inline RangeProof& operator=(const RangeProof& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangeProof& default_instance();

  static inline const RangeProof* internal_default_instance() {
    return reinterpret_cast<const RangeProof*>(
               &_RangeProof_default_instance_);
  }

  void Swap(RangeProof* other);

  // implements Message ----------------------------------------------

  inline RangeProof* New() const PROTOBUF_FINAL { return New(NULL); }

  RangeProof* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RangeProof& from);
  void MergeFrom(const RangeProof& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output)
      const PROTOBUF_FINAL {
    return InternalSerializeWithCachedSizesToArray(
        ::google::protobuf::io::CodedOutputStream::IsDefaultSerializationDeterministic(), output);
  }
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RangeProof* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes value_commitment = 1;
  int value_commitment_size() const;
  void clear_value_commitment();
  static const int kValueCommitmentFieldNumber = 1;
  const ::std::string& value_commitment(int index) const;
  ::std::string* mutable_value_commitment(int index);
  void set_value_commitment(int index, const ::std::string& value);
  void set_value_commitment(int index, const char* value);
  void set_value_commitment(int index, const void* value, size_t size);
  ::std::string* add_value_commitment();
  void add_value_commitment(const ::std::string& value);
  void add_value_commitment(const char* value);
  void add_value_commitment(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& value_commitment() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_value_commitment();

  // repeated bytes aggregated_vector_polynomial_l = 8;
  int aggregated_vector_polynomial_l_size() const;
  void clear_aggregated_vector_polynomial_l();
  static const int kAggregatedVectorPolynomialLFieldNumber = 8;
  const ::std::string& aggregated_vector_polynomial_l(int index) const;
  ::std::string* mutable_aggregated_vector_polynomial_l(int index);
  void set_aggregated_vector_polynomial_l(int index, const ::std::string& value);
  void set_aggregated_vector_polynomial_l(int index, const char* value);
  void set_aggregated_vector_polynomial_l(int index, const void* value, size_t size);
  ::std::string* add_aggregated_vector_polynomial_l();
  void add_aggregated_vector_polynomial_l(const ::std::string& value);
  void add_aggregated_vector_polynomial_l(const char* value);
  void add_aggregated_vector_polynomial_l(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& aggregated_vector_polynomial_l() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_aggregated_vector_polynomial_l();

  // repeated bytes aggregated_vector_polynomial_r = 9;
  int aggregated_vector_polynomial_r_size() const;
  void clear_aggregated_vector_polynomial_r();
  static const int kAggregatedVectorPolynomialRFieldNumber = 9;
  const ::std::string& aggregated_vector_polynomial_r(int index) const;
  ::std::string* mutable_aggregated_vector_polynomial_r(int index);
  void set_aggregated_vector_polynomial_r(int index, const ::std::string& value);
  void set_aggregated_vector_polynomial_r(int index, const char* value);
  void set_aggregated_vector_polynomial_r(int index, const void* value, size_t size);
  ::std::string* add_aggregated_vector_polynomial_r();
  void add_aggregated_vector_polynomial_r(const ::std::string& value);
  void add_aggregated_vector_polynomial_r(const char* value);
  void add_aggregated_vector_polynomial_r(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& aggregated_vector_polynomial_r() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_aggregated_vector_polynomial_r();

  // bytes bit_commitment = 2;
  void clear_bit_commitment();
  static const int kBitCommitmentFieldNumber = 2;
  const ::std::string& bit_commitment() const;
  void set_bit_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_bit_commitment(::std::string&& value);
  #endif
  void set_bit_commitment(const char* value);
  void set_bit_commitment(const void* value, size_t size);
  ::std::string* mutable_bit_commitment();
  ::std::string* release_bit_commitment();
  void set_allocated_bit_commitment(::std::string* bit_commitment);

  // bytes per_bit_blinding_factor_commitment = 3;
  void clear_per_bit_blinding_factor_commitment();
  static const int kPerBitBlindingFactorCommitmentFieldNumber = 3;
  const ::std::string& per_bit_blinding_factor_commitment() const;
  void set_per_bit_blinding_factor_commitment(const ::std::string& value);
  #if LANG_CXX11
  void set_per_bit_blinding_factor_commitment(::std::string&& value);
  #endif
  void set_per_bit_blinding_factor_commitment(const char* value);
  void set_per_bit_blinding_factor_commitment(const void* value, size_t size);
  ::std::string* mutable_per_bit_blinding_factor_commitment();
  ::std::string* release_per_bit_blinding_factor_commitment();
  void set_allocated_per_bit_blinding_factor_commitment(::std::string* per_bit_blinding_factor_commitment);

  // bytes poly_commitment_t1 = 4;
  void clear_poly_commitment_t1();
  static const int kPolyCommitmentT1FieldNumber = 4;
  const ::std::string& poly_commitment_t1() const;
  void set_poly_commitment_t1(const ::std::string& value);
  #if LANG_CXX11
  void set_poly_commitment_t1(::std::string&& value);
  #endif
  void set_poly_commitment_t1(const char* value);
  void set_poly_commitment_t1(const void* value, size_t size);
  ::std::string* mutable_poly_commitment_t1();
  ::std::string* release_poly_commitment_t1();
  void set_allocated_poly_commitment_t1(::std::string* poly_commitment_t1);

  // bytes poly_commitment_t2 = 5;
  void clear_poly_commitment_t2();
  static const int kPolyCommitmentT2FieldNumber = 5;
  const ::std::string& poly_commitment_t2() const;
  void set_poly_commitment_t2(const ::std::string& value);
  #if LANG_CXX11
  void set_poly_commitment_t2(::std::string&& value);
  #endif
  void set_poly_commitment_t2(const char* value);
  void set_poly_commitment_t2(const void* value, size_t size);
  ::std::string* mutable_poly_commitment_t2();
  ::std::string* release_poly_commitment_t2();
  void set_allocated_poly_commitment_t2(::std::string* poly_commitment_t2);

  // bytes proof_of_share_tau = 6;
  void clear_proof_of_share_tau();
  static const int kProofOfShareTauFieldNumber = 6;
  const ::std::string& proof_of_share_tau() const;
  void set_proof_of_share_tau(const ::std::string& value);
  #if LANG_CXX11
  void set_proof_of_share_tau(::std::string&& value);
  #endif
  void set_proof_of_share_tau(const char* value);
  void set_proof_of_share_tau(const void* value, size_t size);
  ::std::string* mutable_proof_of_share_tau();
  ::std::string* release_proof_of_share_tau();
  void set_allocated_proof_of_share_tau(::std::string* proof_of_share_tau);

  // bytes proof_of_share_mu = 7;
  void clear_proof_of_share_mu();
  static const int kProofOfShareMuFieldNumber = 7;
  const ::std::string& proof_of_share_mu() const;
  void set_proof_of_share_mu(const ::std::string& value);
  #if LANG_CXX11
  void set_proof_of_share_mu(::std::string&& value);
  #endif
  void set_proof_of_share_mu(const char* value);
  void set_proof_of_share_mu(const void* value, size_t size);
  ::std::string* mutable_proof_of_share_mu();
  ::std::string* release_proof_of_share_mu();
  void set_allocated_proof_of_share_mu(::std::string* proof_of_share_mu);

  // bytes a_prime_0 = 10;
  void clear_a_prime_0();
  static const int kAPrime0FieldNumber = 10;
  const ::std::string& a_prime_0() const;
  void set_a_prime_0(const ::std::string& value);
  #if LANG_CXX11
  void set_a_prime_0(::std::string&& value);
  #endif
  void set_a_prime_0(const char* value);
  void set_a_prime_0(const void* value, size_t size);
  ::std::string* mutable_a_prime_0();
  ::std::string* release_a_prime_0();
  void set_allocated_a_prime_0(::std::string* a_prime_0);

  // bytes b_prime_0 = 11;
  void clear_b_prime_0();
  static const int kBPrime0FieldNumber = 11;
  const ::std::string& b_prime_0() const;
  void set_b_prime_0(const ::std::string& value);
  #if LANG_CXX11
  void set_b_prime_0(::std::string&& value);
  #endif
  void set_b_prime_0(const char* value);
  void set_b_prime_0(const void* value, size_t size);
  ::std::string* mutable_b_prime_0();
  ::std::string* release_b_prime_0();
  void set_allocated_b_prime_0(::std::string* b_prime_0);

  // bytes t = 12;
  void clear_t();
  static const int kTFieldNumber = 12;
  const ::std::string& t() const;
  void set_t(const ::std::string& value);
  #if LANG_CXX11
  void set_t(::std::string&& value);
  #endif
  void set_t(const char* value);
  void set_t(const void* value, size_t size);
  ::std::string* mutable_t();
  ::std::string* release_t();
  void set_allocated_t(::std::string* t);

  // @@protoc_insertion_point(class_scope:Catalyst.Protocol.Transaction.RangeProof)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> value_commitment_;
  ::google::protobuf::RepeatedPtrField< ::std::string> aggregated_vector_polynomial_l_;
  ::google::protobuf::RepeatedPtrField< ::std::string> aggregated_vector_polynomial_r_;
  ::google::protobuf::internal::ArenaStringPtr bit_commitment_;
  ::google::protobuf::internal::ArenaStringPtr per_bit_blinding_factor_commitment_;
  ::google::protobuf::internal::ArenaStringPtr poly_commitment_t1_;
  ::google::protobuf::internal::ArenaStringPtr poly_commitment_t2_;
  ::google::protobuf::internal::ArenaStringPtr proof_of_share_tau_;
  ::google::protobuf::internal::ArenaStringPtr proof_of_share_mu_;
  ::google::protobuf::internal::ArenaStringPtr a_prime_0_;
  ::google::protobuf::internal::ArenaStringPtr b_prime_0_;
  ::google::protobuf::internal::ArenaStringPtr t_;
  mutable int _cached_size_;
  friend struct  protobuf_Transaction_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PublicEntry

// .Catalyst.Protocol.Transaction.BaseEntry base = 1;
inline bool PublicEntry::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void PublicEntry::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::Catalyst::Protocol::Transaction::BaseEntry& PublicEntry::base() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.base)
  return base_ != NULL ? *base_
                         : *::Catalyst::Protocol::Transaction::BaseEntry::internal_default_instance();
}
inline ::Catalyst::Protocol::Transaction::BaseEntry* PublicEntry::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::Catalyst::Protocol::Transaction::BaseEntry;
  }
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.base)
  return base_;
}
inline ::Catalyst::Protocol::Transaction::BaseEntry* PublicEntry::release_base() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.base)
  
  ::Catalyst::Protocol::Transaction::BaseEntry* temp = base_;
  base_ = NULL;
  return temp;
}
inline void PublicEntry::set_allocated_base(::Catalyst::Protocol::Transaction::BaseEntry* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.base)
}

// bytes amount = 2;
inline void PublicEntry::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicEntry::amount() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.amount)
  return amount_.GetNoArena();
}
inline void PublicEntry::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.PublicEntry.amount)
}
#if LANG_CXX11
inline void PublicEntry::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.PublicEntry.amount)
}
#endif
inline void PublicEntry::set_amount(const char* value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.PublicEntry.amount)
}
inline void PublicEntry::set_amount(const void* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.PublicEntry.amount)
}
inline ::std::string* PublicEntry::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicEntry::release_amount() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicEntry::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.amount)
}

// bytes data = 3;
inline void PublicEntry::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicEntry::data() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.data)
  return data_.GetNoArena();
}
inline void PublicEntry::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.PublicEntry.data)
}
#if LANG_CXX11
inline void PublicEntry::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.PublicEntry.data)
}
#endif
inline void PublicEntry::set_data(const char* value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.PublicEntry.data)
}
inline void PublicEntry::set_data(const void* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.PublicEntry.data)
}
inline ::std::string* PublicEntry::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicEntry::release_data() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicEntry::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.data)
}

// .google.protobuf.Timestamp timestamp = 4;
inline bool PublicEntry::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void PublicEntry::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& PublicEntry::timestamp() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.timestamp)
  return timestamp_ != NULL ? *timestamp_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* PublicEntry::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* PublicEntry::release_timestamp() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void PublicEntry::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.timestamp)
}

// .Catalyst.Protocol.Cryptography.Signature signature = 5;
inline bool PublicEntry::has_signature() const {
  return this != internal_default_instance() && signature_ != NULL;
}
inline void PublicEntry::clear_signature() {
  if (GetArenaNoVirtual() == NULL && signature_ != NULL) delete signature_;
  signature_ = NULL;
}
inline const ::Catalyst::Protocol::Cryptography::Signature& PublicEntry::signature() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.signature)
  return signature_ != NULL ? *signature_
                         : *::Catalyst::Protocol::Cryptography::Signature::internal_default_instance();
}
inline ::Catalyst::Protocol::Cryptography::Signature* PublicEntry::mutable_signature() {
  
  if (signature_ == NULL) {
    signature_ = new ::Catalyst::Protocol::Cryptography::Signature;
  }
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.signature)
  return signature_;
}
inline ::Catalyst::Protocol::Cryptography::Signature* PublicEntry::release_signature() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.signature)
  
  ::Catalyst::Protocol::Cryptography::Signature* temp = signature_;
  signature_ = NULL;
  return temp;
}
inline void PublicEntry::set_allocated_signature(::Catalyst::Protocol::Cryptography::Signature* signature) {
  delete signature_;
  signature_ = signature;
  if (signature) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.signature)
}

// bytes gas_price = 6;
inline void PublicEntry::clear_gas_price() {
  gas_price_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicEntry::gas_price() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
  return gas_price_.GetNoArena();
}
inline void PublicEntry::set_gas_price(const ::std::string& value) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
}
#if LANG_CXX11
inline void PublicEntry::set_gas_price(::std::string&& value) {
  
  gas_price_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
}
#endif
inline void PublicEntry::set_gas_price(const char* value) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
}
inline void PublicEntry::set_gas_price(const void* value, size_t size) {
  
  gas_price_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
}
inline ::std::string* PublicEntry::mutable_gas_price() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
  return gas_price_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicEntry::release_gas_price() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
  
  return gas_price_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicEntry::set_allocated_gas_price(::std::string* gas_price) {
  if (gas_price != NULL) {
    
  } else {
    
  }
  gas_price_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gas_price);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.PublicEntry.gas_price)
}

// uint64 gas_limit = 7;
inline void PublicEntry::clear_gas_limit() {
  gas_limit_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 PublicEntry::gas_limit() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.PublicEntry.gas_limit)
  return gas_limit_;
}
inline void PublicEntry::set_gas_limit(::google::protobuf::uint64 value) {
  
  gas_limit_ = value;
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.PublicEntry.gas_limit)
}

// -------------------------------------------------------------------

// ConfidentialEntry

// .Catalyst.Protocol.Transaction.BaseEntry base = 1;
inline bool ConfidentialEntry::has_base() const {
  return this != internal_default_instance() && base_ != NULL;
}
inline void ConfidentialEntry::clear_base() {
  if (GetArenaNoVirtual() == NULL && base_ != NULL) delete base_;
  base_ = NULL;
}
inline const ::Catalyst::Protocol::Transaction::BaseEntry& ConfidentialEntry::base() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.ConfidentialEntry.base)
  return base_ != NULL ? *base_
                         : *::Catalyst::Protocol::Transaction::BaseEntry::internal_default_instance();
}
inline ::Catalyst::Protocol::Transaction::BaseEntry* ConfidentialEntry::mutable_base() {
  
  if (base_ == NULL) {
    base_ = new ::Catalyst::Protocol::Transaction::BaseEntry;
  }
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.ConfidentialEntry.base)
  return base_;
}
inline ::Catalyst::Protocol::Transaction::BaseEntry* ConfidentialEntry::release_base() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.ConfidentialEntry.base)
  
  ::Catalyst::Protocol::Transaction::BaseEntry* temp = base_;
  base_ = NULL;
  return temp;
}
inline void ConfidentialEntry::set_allocated_base(::Catalyst::Protocol::Transaction::BaseEntry* base) {
  delete base_;
  base_ = base;
  if (base) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.ConfidentialEntry.base)
}

// bytes pedersen_commitment = 2;
inline void ConfidentialEntry::clear_pedersen_commitment() {
  pedersen_commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConfidentialEntry::pedersen_commitment() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
  return pedersen_commitment_.GetNoArena();
}
inline void ConfidentialEntry::set_pedersen_commitment(const ::std::string& value) {
  
  pedersen_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
}
#if LANG_CXX11
inline void ConfidentialEntry::set_pedersen_commitment(::std::string&& value) {
  
  pedersen_commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
}
#endif
inline void ConfidentialEntry::set_pedersen_commitment(const char* value) {
  
  pedersen_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
}
inline void ConfidentialEntry::set_pedersen_commitment(const void* value, size_t size) {
  
  pedersen_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
}
inline ::std::string* ConfidentialEntry::mutable_pedersen_commitment() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
  return pedersen_commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConfidentialEntry::release_pedersen_commitment() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
  
  return pedersen_commitment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConfidentialEntry::set_allocated_pedersen_commitment(::std::string* pedersen_commitment) {
  if (pedersen_commitment != NULL) {
    
  } else {
    
  }
  pedersen_commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pedersen_commitment);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.ConfidentialEntry.pedersen_commitment)
}

// .Catalyst.Protocol.Transaction.RangeProof range_proof = 3;
inline bool ConfidentialEntry::has_range_proof() const {
  return this != internal_default_instance() && range_proof_ != NULL;
}
inline void ConfidentialEntry::clear_range_proof() {
  if (GetArenaNoVirtual() == NULL && range_proof_ != NULL) delete range_proof_;
  range_proof_ = NULL;
}
inline const ::Catalyst::Protocol::Transaction::RangeProof& ConfidentialEntry::range_proof() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.ConfidentialEntry.range_proof)
  return range_proof_ != NULL ? *range_proof_
                         : *::Catalyst::Protocol::Transaction::RangeProof::internal_default_instance();
}
inline ::Catalyst::Protocol::Transaction::RangeProof* ConfidentialEntry::mutable_range_proof() {
  
  if (range_proof_ == NULL) {
    range_proof_ = new ::Catalyst::Protocol::Transaction::RangeProof;
  }
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.ConfidentialEntry.range_proof)
  return range_proof_;
}
inline ::Catalyst::Protocol::Transaction::RangeProof* ConfidentialEntry::release_range_proof() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.ConfidentialEntry.range_proof)
  
  ::Catalyst::Protocol::Transaction::RangeProof* temp = range_proof_;
  range_proof_ = NULL;
  return temp;
}
inline void ConfidentialEntry::set_allocated_range_proof(::Catalyst::Protocol::Transaction::RangeProof* range_proof) {
  delete range_proof_;
  range_proof_ = range_proof;
  if (range_proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.ConfidentialEntry.range_proof)
}

// -------------------------------------------------------------------

// BaseEntry

// uint64 nonce = 1;
inline void BaseEntry::clear_nonce() {
  nonce_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BaseEntry::nonce() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.BaseEntry.nonce)
  return nonce_;
}
inline void BaseEntry::set_nonce(::google::protobuf::uint64 value) {
  
  nonce_ = value;
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.BaseEntry.nonce)
}

// bytes receiver_public_key = 2;
inline void BaseEntry::clear_receiver_public_key() {
  receiver_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BaseEntry::receiver_public_key() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
  return receiver_public_key_.GetNoArena();
}
inline void BaseEntry::set_receiver_public_key(const ::std::string& value) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
}
#if LANG_CXX11
inline void BaseEntry::set_receiver_public_key(::std::string&& value) {
  
  receiver_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
}
#endif
inline void BaseEntry::set_receiver_public_key(const char* value) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
}
inline void BaseEntry::set_receiver_public_key(const void* value, size_t size) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
}
inline ::std::string* BaseEntry::mutable_receiver_public_key() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
  return receiver_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseEntry::release_receiver_public_key() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
  
  return receiver_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseEntry::set_allocated_receiver_public_key(::std::string* receiver_public_key) {
  if (receiver_public_key != NULL) {
    
  } else {
    
  }
  receiver_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver_public_key);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.BaseEntry.receiver_public_key)
}

// bytes sender_public_key = 3;
inline void BaseEntry::clear_sender_public_key() {
  sender_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BaseEntry::sender_public_key() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
  return sender_public_key_.GetNoArena();
}
inline void BaseEntry::set_sender_public_key(const ::std::string& value) {
  
  sender_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
}
#if LANG_CXX11
inline void BaseEntry::set_sender_public_key(::std::string&& value) {
  
  sender_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
}
#endif
inline void BaseEntry::set_sender_public_key(const char* value) {
  
  sender_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
}
inline void BaseEntry::set_sender_public_key(const void* value, size_t size) {
  
  sender_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
}
inline ::std::string* BaseEntry::mutable_sender_public_key() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
  return sender_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseEntry::release_sender_public_key() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
  
  return sender_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseEntry::set_allocated_sender_public_key(::std::string* sender_public_key) {
  if (sender_public_key != NULL) {
    
  } else {
    
  }
  sender_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sender_public_key);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.BaseEntry.sender_public_key)
}

// bytes transaction_fees = 4;
inline void BaseEntry::clear_transaction_fees() {
  transaction_fees_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BaseEntry::transaction_fees() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
  return transaction_fees_.GetNoArena();
}
inline void BaseEntry::set_transaction_fees(const ::std::string& value) {
  
  transaction_fees_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
}
#if LANG_CXX11
inline void BaseEntry::set_transaction_fees(::std::string&& value) {
  
  transaction_fees_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
}
#endif
inline void BaseEntry::set_transaction_fees(const char* value) {
  
  transaction_fees_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
}
inline void BaseEntry::set_transaction_fees(const void* value, size_t size) {
  
  transaction_fees_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
}
inline ::std::string* BaseEntry::mutable_transaction_fees() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
  return transaction_fees_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BaseEntry::release_transaction_fees() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
  
  return transaction_fees_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BaseEntry::set_allocated_transaction_fees(::std::string* transaction_fees) {
  if (transaction_fees != NULL) {
    
  } else {
    
  }
  transaction_fees_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transaction_fees);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.BaseEntry.transaction_fees)
}

// -------------------------------------------------------------------

// CoinbaseEntry

// bytes receiver_public_key = 1;
inline void CoinbaseEntry::clear_receiver_public_key() {
  receiver_public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CoinbaseEntry::receiver_public_key() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
  return receiver_public_key_.GetNoArena();
}
inline void CoinbaseEntry::set_receiver_public_key(const ::std::string& value) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
}
#if LANG_CXX11
inline void CoinbaseEntry::set_receiver_public_key(::std::string&& value) {
  
  receiver_public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
}
#endif
inline void CoinbaseEntry::set_receiver_public_key(const char* value) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
}
inline void CoinbaseEntry::set_receiver_public_key(const void* value, size_t size) {
  
  receiver_public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
}
inline ::std::string* CoinbaseEntry::mutable_receiver_public_key() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
  return receiver_public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoinbaseEntry::release_receiver_public_key() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
  
  return receiver_public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoinbaseEntry::set_allocated_receiver_public_key(::std::string* receiver_public_key) {
  if (receiver_public_key != NULL) {
    
  } else {
    
  }
  receiver_public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), receiver_public_key);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.CoinbaseEntry.receiver_public_key)
}

// bytes amount = 2;
inline void CoinbaseEntry::clear_amount() {
  amount_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CoinbaseEntry::amount() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
  return amount_.GetNoArena();
}
inline void CoinbaseEntry::set_amount(const ::std::string& value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
}
#if LANG_CXX11
inline void CoinbaseEntry::set_amount(::std::string&& value) {
  
  amount_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
}
#endif
inline void CoinbaseEntry::set_amount(const char* value) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
}
inline void CoinbaseEntry::set_amount(const void* value, size_t size) {
  
  amount_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
}
inline ::std::string* CoinbaseEntry::mutable_amount() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
  return amount_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoinbaseEntry::release_amount() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
  
  return amount_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoinbaseEntry::set_allocated_amount(::std::string* amount) {
  if (amount != NULL) {
    
  } else {
    
  }
  amount_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), amount);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.CoinbaseEntry.amount)
}

// -------------------------------------------------------------------

// RangeProof

// repeated bytes value_commitment = 1;
inline int RangeProof::value_commitment_size() const {
  return value_commitment_.size();
}
inline void RangeProof::clear_value_commitment() {
  value_commitment_.Clear();
}
inline const ::std::string& RangeProof::value_commitment(int index) const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  return value_commitment_.Get(index);
}
inline ::std::string* RangeProof::mutable_value_commitment(int index) {
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  return value_commitment_.Mutable(index);
}
inline void RangeProof::set_value_commitment(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  value_commitment_.Mutable(index)->assign(value);
}
inline void RangeProof::set_value_commitment(int index, const char* value) {
  value_commitment_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
}
inline void RangeProof::set_value_commitment(int index, const void* value, size_t size) {
  value_commitment_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
}
inline ::std::string* RangeProof::add_value_commitment() {
  // @@protoc_insertion_point(field_add_mutable:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  return value_commitment_.Add();
}
inline void RangeProof::add_value_commitment(const ::std::string& value) {
  value_commitment_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
}
inline void RangeProof::add_value_commitment(const char* value) {
  value_commitment_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
}
inline void RangeProof::add_value_commitment(const void* value, size_t size) {
  value_commitment_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RangeProof::value_commitment() const {
  // @@protoc_insertion_point(field_list:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  return value_commitment_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RangeProof::mutable_value_commitment() {
  // @@protoc_insertion_point(field_mutable_list:Catalyst.Protocol.Transaction.RangeProof.value_commitment)
  return &value_commitment_;
}

// bytes bit_commitment = 2;
inline void RangeProof::clear_bit_commitment() {
  bit_commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::bit_commitment() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
  return bit_commitment_.GetNoArena();
}
inline void RangeProof::set_bit_commitment(const ::std::string& value) {
  
  bit_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
}
#if LANG_CXX11
inline void RangeProof::set_bit_commitment(::std::string&& value) {
  
  bit_commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
}
#endif
inline void RangeProof::set_bit_commitment(const char* value) {
  
  bit_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
}
inline void RangeProof::set_bit_commitment(const void* value, size_t size) {
  
  bit_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
}
inline ::std::string* RangeProof::mutable_bit_commitment() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
  return bit_commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_bit_commitment() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
  
  return bit_commitment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_bit_commitment(::std::string* bit_commitment) {
  if (bit_commitment != NULL) {
    
  } else {
    
  }
  bit_commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), bit_commitment);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.bit_commitment)
}

// bytes per_bit_blinding_factor_commitment = 3;
inline void RangeProof::clear_per_bit_blinding_factor_commitment() {
  per_bit_blinding_factor_commitment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::per_bit_blinding_factor_commitment() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
  return per_bit_blinding_factor_commitment_.GetNoArena();
}
inline void RangeProof::set_per_bit_blinding_factor_commitment(const ::std::string& value) {
  
  per_bit_blinding_factor_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
}
#if LANG_CXX11
inline void RangeProof::set_per_bit_blinding_factor_commitment(::std::string&& value) {
  
  per_bit_blinding_factor_commitment_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
}
#endif
inline void RangeProof::set_per_bit_blinding_factor_commitment(const char* value) {
  
  per_bit_blinding_factor_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
}
inline void RangeProof::set_per_bit_blinding_factor_commitment(const void* value, size_t size) {
  
  per_bit_blinding_factor_commitment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
}
inline ::std::string* RangeProof::mutable_per_bit_blinding_factor_commitment() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
  return per_bit_blinding_factor_commitment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_per_bit_blinding_factor_commitment() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
  
  return per_bit_blinding_factor_commitment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_per_bit_blinding_factor_commitment(::std::string* per_bit_blinding_factor_commitment) {
  if (per_bit_blinding_factor_commitment != NULL) {
    
  } else {
    
  }
  per_bit_blinding_factor_commitment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), per_bit_blinding_factor_commitment);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.per_bit_blinding_factor_commitment)
}

// bytes poly_commitment_t1 = 4;
inline void RangeProof::clear_poly_commitment_t1() {
  poly_commitment_t1_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::poly_commitment_t1() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
  return poly_commitment_t1_.GetNoArena();
}
inline void RangeProof::set_poly_commitment_t1(const ::std::string& value) {
  
  poly_commitment_t1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
}
#if LANG_CXX11
inline void RangeProof::set_poly_commitment_t1(::std::string&& value) {
  
  poly_commitment_t1_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
}
#endif
inline void RangeProof::set_poly_commitment_t1(const char* value) {
  
  poly_commitment_t1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
}
inline void RangeProof::set_poly_commitment_t1(const void* value, size_t size) {
  
  poly_commitment_t1_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
}
inline ::std::string* RangeProof::mutable_poly_commitment_t1() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
  return poly_commitment_t1_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_poly_commitment_t1() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
  
  return poly_commitment_t1_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_poly_commitment_t1(::std::string* poly_commitment_t1) {
  if (poly_commitment_t1 != NULL) {
    
  } else {
    
  }
  poly_commitment_t1_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), poly_commitment_t1);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t1)
}

// bytes poly_commitment_t2 = 5;
inline void RangeProof::clear_poly_commitment_t2() {
  poly_commitment_t2_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::poly_commitment_t2() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
  return poly_commitment_t2_.GetNoArena();
}
inline void RangeProof::set_poly_commitment_t2(const ::std::string& value) {
  
  poly_commitment_t2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
}
#if LANG_CXX11
inline void RangeProof::set_poly_commitment_t2(::std::string&& value) {
  
  poly_commitment_t2_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
}
#endif
inline void RangeProof::set_poly_commitment_t2(const char* value) {
  
  poly_commitment_t2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
}
inline void RangeProof::set_poly_commitment_t2(const void* value, size_t size) {
  
  poly_commitment_t2_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
}
inline ::std::string* RangeProof::mutable_poly_commitment_t2() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
  return poly_commitment_t2_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_poly_commitment_t2() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
  
  return poly_commitment_t2_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_poly_commitment_t2(::std::string* poly_commitment_t2) {
  if (poly_commitment_t2 != NULL) {
    
  } else {
    
  }
  poly_commitment_t2_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), poly_commitment_t2);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.poly_commitment_t2)
}

// bytes proof_of_share_tau = 6;
inline void RangeProof::clear_proof_of_share_tau() {
  proof_of_share_tau_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::proof_of_share_tau() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
  return proof_of_share_tau_.GetNoArena();
}
inline void RangeProof::set_proof_of_share_tau(const ::std::string& value) {
  
  proof_of_share_tau_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
}
#if LANG_CXX11
inline void RangeProof::set_proof_of_share_tau(::std::string&& value) {
  
  proof_of_share_tau_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
}
#endif
inline void RangeProof::set_proof_of_share_tau(const char* value) {
  
  proof_of_share_tau_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
}
inline void RangeProof::set_proof_of_share_tau(const void* value, size_t size) {
  
  proof_of_share_tau_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
}
inline ::std::string* RangeProof::mutable_proof_of_share_tau() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
  return proof_of_share_tau_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_proof_of_share_tau() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
  
  return proof_of_share_tau_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_proof_of_share_tau(::std::string* proof_of_share_tau) {
  if (proof_of_share_tau != NULL) {
    
  } else {
    
  }
  proof_of_share_tau_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proof_of_share_tau);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_tau)
}

// bytes proof_of_share_mu = 7;
inline void RangeProof::clear_proof_of_share_mu() {
  proof_of_share_mu_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::proof_of_share_mu() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
  return proof_of_share_mu_.GetNoArena();
}
inline void RangeProof::set_proof_of_share_mu(const ::std::string& value) {
  
  proof_of_share_mu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
}
#if LANG_CXX11
inline void RangeProof::set_proof_of_share_mu(::std::string&& value) {
  
  proof_of_share_mu_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
}
#endif
inline void RangeProof::set_proof_of_share_mu(const char* value) {
  
  proof_of_share_mu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
}
inline void RangeProof::set_proof_of_share_mu(const void* value, size_t size) {
  
  proof_of_share_mu_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
}
inline ::std::string* RangeProof::mutable_proof_of_share_mu() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
  return proof_of_share_mu_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_proof_of_share_mu() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
  
  return proof_of_share_mu_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_proof_of_share_mu(::std::string* proof_of_share_mu) {
  if (proof_of_share_mu != NULL) {
    
  } else {
    
  }
  proof_of_share_mu_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), proof_of_share_mu);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.proof_of_share_mu)
}

// repeated bytes aggregated_vector_polynomial_l = 8;
inline int RangeProof::aggregated_vector_polynomial_l_size() const {
  return aggregated_vector_polynomial_l_.size();
}
inline void RangeProof::clear_aggregated_vector_polynomial_l() {
  aggregated_vector_polynomial_l_.Clear();
}
inline const ::std::string& RangeProof::aggregated_vector_polynomial_l(int index) const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  return aggregated_vector_polynomial_l_.Get(index);
}
inline ::std::string* RangeProof::mutable_aggregated_vector_polynomial_l(int index) {
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  return aggregated_vector_polynomial_l_.Mutable(index);
}
inline void RangeProof::set_aggregated_vector_polynomial_l(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  aggregated_vector_polynomial_l_.Mutable(index)->assign(value);
}
inline void RangeProof::set_aggregated_vector_polynomial_l(int index, const char* value) {
  aggregated_vector_polynomial_l_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
}
inline void RangeProof::set_aggregated_vector_polynomial_l(int index, const void* value, size_t size) {
  aggregated_vector_polynomial_l_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
}
inline ::std::string* RangeProof::add_aggregated_vector_polynomial_l() {
  // @@protoc_insertion_point(field_add_mutable:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  return aggregated_vector_polynomial_l_.Add();
}
inline void RangeProof::add_aggregated_vector_polynomial_l(const ::std::string& value) {
  aggregated_vector_polynomial_l_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
}
inline void RangeProof::add_aggregated_vector_polynomial_l(const char* value) {
  aggregated_vector_polynomial_l_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
}
inline void RangeProof::add_aggregated_vector_polynomial_l(const void* value, size_t size) {
  aggregated_vector_polynomial_l_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RangeProof::aggregated_vector_polynomial_l() const {
  // @@protoc_insertion_point(field_list:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  return aggregated_vector_polynomial_l_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RangeProof::mutable_aggregated_vector_polynomial_l() {
  // @@protoc_insertion_point(field_mutable_list:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_l)
  return &aggregated_vector_polynomial_l_;
}

// repeated bytes aggregated_vector_polynomial_r = 9;
inline int RangeProof::aggregated_vector_polynomial_r_size() const {
  return aggregated_vector_polynomial_r_.size();
}
inline void RangeProof::clear_aggregated_vector_polynomial_r() {
  aggregated_vector_polynomial_r_.Clear();
}
inline const ::std::string& RangeProof::aggregated_vector_polynomial_r(int index) const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  return aggregated_vector_polynomial_r_.Get(index);
}
inline ::std::string* RangeProof::mutable_aggregated_vector_polynomial_r(int index) {
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  return aggregated_vector_polynomial_r_.Mutable(index);
}
inline void RangeProof::set_aggregated_vector_polynomial_r(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  aggregated_vector_polynomial_r_.Mutable(index)->assign(value);
}
inline void RangeProof::set_aggregated_vector_polynomial_r(int index, const char* value) {
  aggregated_vector_polynomial_r_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
}
inline void RangeProof::set_aggregated_vector_polynomial_r(int index, const void* value, size_t size) {
  aggregated_vector_polynomial_r_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
}
inline ::std::string* RangeProof::add_aggregated_vector_polynomial_r() {
  // @@protoc_insertion_point(field_add_mutable:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  return aggregated_vector_polynomial_r_.Add();
}
inline void RangeProof::add_aggregated_vector_polynomial_r(const ::std::string& value) {
  aggregated_vector_polynomial_r_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
}
inline void RangeProof::add_aggregated_vector_polynomial_r(const char* value) {
  aggregated_vector_polynomial_r_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
}
inline void RangeProof::add_aggregated_vector_polynomial_r(const void* value, size_t size) {
  aggregated_vector_polynomial_r_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RangeProof::aggregated_vector_polynomial_r() const {
  // @@protoc_insertion_point(field_list:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  return aggregated_vector_polynomial_r_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RangeProof::mutable_aggregated_vector_polynomial_r() {
  // @@protoc_insertion_point(field_mutable_list:Catalyst.Protocol.Transaction.RangeProof.aggregated_vector_polynomial_r)
  return &aggregated_vector_polynomial_r_;
}

// bytes a_prime_0 = 10;
inline void RangeProof::clear_a_prime_0() {
  a_prime_0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::a_prime_0() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
  return a_prime_0_.GetNoArena();
}
inline void RangeProof::set_a_prime_0(const ::std::string& value) {
  
  a_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
}
#if LANG_CXX11
inline void RangeProof::set_a_prime_0(::std::string&& value) {
  
  a_prime_0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
}
#endif
inline void RangeProof::set_a_prime_0(const char* value) {
  
  a_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
}
inline void RangeProof::set_a_prime_0(const void* value, size_t size) {
  
  a_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
}
inline ::std::string* RangeProof::mutable_a_prime_0() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
  return a_prime_0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_a_prime_0() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
  
  return a_prime_0_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_a_prime_0(::std::string* a_prime_0) {
  if (a_prime_0 != NULL) {
    
  } else {
    
  }
  a_prime_0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), a_prime_0);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.a_prime_0)
}

// bytes b_prime_0 = 11;
inline void RangeProof::clear_b_prime_0() {
  b_prime_0_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::b_prime_0() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
  return b_prime_0_.GetNoArena();
}
inline void RangeProof::set_b_prime_0(const ::std::string& value) {
  
  b_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
}
#if LANG_CXX11
inline void RangeProof::set_b_prime_0(::std::string&& value) {
  
  b_prime_0_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
}
#endif
inline void RangeProof::set_b_prime_0(const char* value) {
  
  b_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
}
inline void RangeProof::set_b_prime_0(const void* value, size_t size) {
  
  b_prime_0_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
}
inline ::std::string* RangeProof::mutable_b_prime_0() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
  return b_prime_0_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_b_prime_0() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
  
  return b_prime_0_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_b_prime_0(::std::string* b_prime_0) {
  if (b_prime_0 != NULL) {
    
  } else {
    
  }
  b_prime_0_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), b_prime_0);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.b_prime_0)
}

// bytes t = 12;
inline void RangeProof::clear_t() {
  t_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RangeProof::t() const {
  // @@protoc_insertion_point(field_get:Catalyst.Protocol.Transaction.RangeProof.t)
  return t_.GetNoArena();
}
inline void RangeProof::set_t(const ::std::string& value) {
  
  t_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Catalyst.Protocol.Transaction.RangeProof.t)
}
#if LANG_CXX11
inline void RangeProof::set_t(::std::string&& value) {
  
  t_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Catalyst.Protocol.Transaction.RangeProof.t)
}
#endif
inline void RangeProof::set_t(const char* value) {
  
  t_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Catalyst.Protocol.Transaction.RangeProof.t)
}
inline void RangeProof::set_t(const void* value, size_t size) {
  
  t_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Catalyst.Protocol.Transaction.RangeProof.t)
}
inline ::std::string* RangeProof::mutable_t() {
  
  // @@protoc_insertion_point(field_mutable:Catalyst.Protocol.Transaction.RangeProof.t)
  return t_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RangeProof::release_t() {
  // @@protoc_insertion_point(field_release:Catalyst.Protocol.Transaction.RangeProof.t)
  
  return t_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RangeProof::set_allocated_t(::std::string* t) {
  if (t != NULL) {
    
  } else {
    
  }
  t_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), t);
  // @@protoc_insertion_point(field_set_allocated:Catalyst.Protocol.Transaction.RangeProof.t)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace Transaction
}  // namespace Protocol
}  // namespace Catalyst

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::Catalyst::Protocol::Transaction::TransactionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Catalyst::Protocol::Transaction::TransactionType>() {
  return ::Catalyst::Protocol::Transaction::TransactionType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Transaction_2eproto__INCLUDED
