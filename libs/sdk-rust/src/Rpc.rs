// This file is generated by rust-protobuf 2.10.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `Rpc.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_10_0;

#[derive(PartialEq,Clone,Default)]
pub struct VersionRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionRequest {
    fn default() -> &'a VersionRequest {
        <VersionRequest as ::protobuf::Message>::default_instance()
    }
}

impl VersionRequest {
    pub fn new() -> VersionRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for VersionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionRequest {
        VersionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &VersionRequest| { &m.query },
                    |m: &mut VersionRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VersionRequest>(
                    "VersionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VersionRequest {
        static mut instance: ::protobuf::lazy::Lazy<VersionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VersionRequest,
        };
        unsafe {
            instance.get(VersionRequest::new)
        }
    }
}

impl ::protobuf::Clear for VersionRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VersionResponse {
    // message fields
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VersionResponse {
    fn default() -> &'a VersionResponse {
        <VersionResponse as ::protobuf::Message>::default_instance()
    }
}

impl VersionResponse {
    pub fn new() -> VersionResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VersionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VersionResponse {
        VersionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &VersionResponse| { &m.version },
                    |m: &mut VersionResponse| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VersionResponse>(
                    "VersionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VersionResponse {
        static mut instance: ::protobuf::lazy::Lazy<VersionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VersionResponse,
        };
        unsafe {
            instance.get(VersionResponse::new)
        }
    }
}

impl ::protobuf::Clear for VersionResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VersionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VersionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoRequest {
    fn default() -> &'a GetInfoRequest {
        <GetInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoRequest {
    pub fn new() -> GetInfoRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for GetInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoRequest {
        GetInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &GetInfoRequest| { &m.query },
                    |m: &mut GetInfoRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoRequest>(
                    "GetInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoRequest,
        };
        unsafe {
            instance.get(GetInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetInfoResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetInfoResponse {
    fn default() -> &'a GetInfoResponse {
        <GetInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetInfoResponse {
    pub fn new() -> GetInfoResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetInfoResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetInfoResponse {
        GetInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &GetInfoResponse| { &m.query },
                    |m: &mut GetInfoResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetInfoResponse>(
                    "GetInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetInfoResponse,
        };
        unsafe {
            instance.get(GetInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetInfoResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWalletRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWalletRequest {
    fn default() -> &'a CreateWalletRequest {
        <CreateWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateWalletRequest {
    pub fn new() -> CreateWalletRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for CreateWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWalletRequest {
        CreateWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &CreateWalletRequest| { &m.query },
                    |m: &mut CreateWalletRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateWalletRequest>(
                    "CreateWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateWalletRequest,
        };
        unsafe {
            instance.get(CreateWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateWalletRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWalletResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWalletResponse {
    fn default() -> &'a CreateWalletResponse {
        <CreateWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateWalletResponse {
    pub fn new() -> CreateWalletResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWalletResponse {
        CreateWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &CreateWalletResponse| { &m.query },
                    |m: &mut CreateWalletResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateWalletResponse>(
                    "CreateWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateWalletResponse,
        };
        unsafe {
            instance.get(CreateWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateWalletResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListWalletRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWalletRequest {
    fn default() -> &'a ListWalletRequest {
        <ListWalletRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListWalletRequest {
    pub fn new() -> ListWalletRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for ListWalletRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWalletRequest {
        ListWalletRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &ListWalletRequest| { &m.query },
                    |m: &mut ListWalletRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListWalletRequest>(
                    "ListWalletRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListWalletRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListWalletRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListWalletRequest,
        };
        unsafe {
            instance.get(ListWalletRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListWalletRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWalletRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWalletRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListWalletResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListWalletResponse {
    fn default() -> &'a ListWalletResponse {
        <ListWalletResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListWalletResponse {
    pub fn new() -> ListWalletResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListWalletResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListWalletResponse {
        ListWalletResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &ListWalletResponse| { &m.query },
                    |m: &mut ListWalletResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListWalletResponse>(
                    "ListWalletResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListWalletResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListWalletResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListWalletResponse,
        };
        unsafe {
            instance.get(ListWalletResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListWalletResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListWalletResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListWalletResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateAddressRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateAddressRequest {
    fn default() -> &'a CreateAddressRequest {
        <CreateAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateAddressRequest {
    pub fn new() -> CreateAddressRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for CreateAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateAddressRequest {
        CreateAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &CreateAddressRequest| { &m.query },
                    |m: &mut CreateAddressRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateAddressRequest>(
                    "CreateAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateAddressRequest,
        };
        unsafe {
            instance.get(CreateAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateAddressRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateAddressResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateAddressResponse {
    fn default() -> &'a CreateAddressResponse {
        <CreateAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateAddressResponse {
    pub fn new() -> CreateAddressResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateAddressResponse {
        CreateAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &CreateAddressResponse| { &m.query },
                    |m: &mut CreateAddressResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateAddressResponse>(
                    "CreateAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateAddressResponse,
        };
        unsafe {
            instance.get(CreateAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateAddressResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressRequest {
    fn default() -> &'a GetAddressRequest {
        <GetAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressRequest {
    pub fn new() -> GetAddressRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for GetAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressRequest {
        GetAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &GetAddressRequest| { &m.query },
                    |m: &mut GetAddressRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAddressRequest>(
                    "GetAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAddressRequest,
        };
        unsafe {
            instance.get(GetAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetAddressRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetAddressResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAddressResponse {
    fn default() -> &'a GetAddressResponse {
        <GetAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAddressResponse {
    pub fn new() -> GetAddressResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAddressResponse {
        GetAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &GetAddressResponse| { &m.query },
                    |m: &mut GetAddressResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetAddressResponse>(
                    "GetAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetAddressResponse,
        };
        unsafe {
            instance.get(GetAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetAddressResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAddressRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAddressRequest {
    fn default() -> &'a ListAddressRequest {
        <ListAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListAddressRequest {
    pub fn new() -> ListAddressRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for ListAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAddressRequest {
        ListAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &ListAddressRequest| { &m.query },
                    |m: &mut ListAddressRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListAddressRequest>(
                    "ListAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<ListAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListAddressRequest,
        };
        unsafe {
            instance.get(ListAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for ListAddressRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListAddressResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListAddressResponse {
    fn default() -> &'a ListAddressResponse {
        <ListAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListAddressResponse {
    pub fn new() -> ListAddressResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListAddressResponse {
        ListAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &ListAddressResponse| { &m.query },
                    |m: &mut ListAddressResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ListAddressResponse>(
                    "ListAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ListAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<ListAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ListAddressResponse,
        };
        unsafe {
            instance.get(ListAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for ListAddressResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidateAddressRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidateAddressRequest {
    fn default() -> &'a ValidateAddressRequest {
        <ValidateAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl ValidateAddressRequest {
    pub fn new() -> ValidateAddressRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for ValidateAddressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidateAddressRequest {
        ValidateAddressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &ValidateAddressRequest| { &m.query },
                    |m: &mut ValidateAddressRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValidateAddressRequest>(
                    "ValidateAddressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValidateAddressRequest {
        static mut instance: ::protobuf::lazy::Lazy<ValidateAddressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValidateAddressRequest,
        };
        unsafe {
            instance.get(ValidateAddressRequest::new)
        }
    }
}

impl ::protobuf::Clear for ValidateAddressRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidateAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateAddressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ValidateAddressResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ValidateAddressResponse {
    fn default() -> &'a ValidateAddressResponse {
        <ValidateAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValidateAddressResponse {
    pub fn new() -> ValidateAddressResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ValidateAddressResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ValidateAddressResponse {
        ValidateAddressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &ValidateAddressResponse| { &m.query },
                    |m: &mut ValidateAddressResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ValidateAddressResponse>(
                    "ValidateAddressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ValidateAddressResponse {
        static mut instance: ::protobuf::lazy::Lazy<ValidateAddressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ValidateAddressResponse,
        };
        unsafe {
            instance.get(ValidateAddressResponse::new)
        }
    }
}

impl ::protobuf::Clear for ValidateAddressResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ValidateAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValidateAddressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBalanceRequest {
    fn default() -> &'a GetBalanceRequest {
        <GetBalanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetBalanceRequest {
    pub fn new() -> GetBalanceRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for GetBalanceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceRequest {
        GetBalanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &GetBalanceRequest| { &m.query },
                    |m: &mut GetBalanceRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceRequest>(
                    "GetBalanceRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceRequest,
        };
        unsafe {
            instance.get(GetBalanceRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetBalanceResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetBalanceResponse {
    fn default() -> &'a GetBalanceResponse {
        <GetBalanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetBalanceResponse {
    pub fn new() -> GetBalanceResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetBalanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetBalanceResponse {
        GetBalanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &GetBalanceResponse| { &m.query },
                    |m: &mut GetBalanceResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetBalanceResponse>(
                    "GetBalanceResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetBalanceResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetBalanceResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetBalanceResponse,
        };
        unsafe {
            instance.get(GetBalanceResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetBalanceResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetBalanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetBalanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRawTransactionRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRawTransactionRequest {
    fn default() -> &'a CreateRawTransactionRequest {
        <CreateRawTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateRawTransactionRequest {
    pub fn new() -> CreateRawTransactionRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for CreateRawTransactionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRawTransactionRequest {
        CreateRawTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &CreateRawTransactionRequest| { &m.query },
                    |m: &mut CreateRawTransactionRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRawTransactionRequest>(
                    "CreateRawTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateRawTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<CreateRawTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRawTransactionRequest,
        };
        unsafe {
            instance.get(CreateRawTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for CreateRawTransactionRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRawTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRawTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateRawTransactionResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateRawTransactionResponse {
    fn default() -> &'a CreateRawTransactionResponse {
        <CreateRawTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateRawTransactionResponse {
    pub fn new() -> CreateRawTransactionResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateRawTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateRawTransactionResponse {
        CreateRawTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &CreateRawTransactionResponse| { &m.query },
                    |m: &mut CreateRawTransactionResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CreateRawTransactionResponse>(
                    "CreateRawTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CreateRawTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CreateRawTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CreateRawTransactionResponse,
        };
        unsafe {
            instance.get(CreateRawTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CreateRawTransactionResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateRawTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateRawTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignRawTransactionRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignRawTransactionRequest {
    fn default() -> &'a SignRawTransactionRequest {
        <SignRawTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignRawTransactionRequest {
    pub fn new() -> SignRawTransactionRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SignRawTransactionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignRawTransactionRequest {
        SignRawTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SignRawTransactionRequest| { &m.query },
                    |m: &mut SignRawTransactionRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignRawTransactionRequest>(
                    "SignRawTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignRawTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignRawTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignRawTransactionRequest,
        };
        unsafe {
            instance.get(SignRawTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignRawTransactionRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignRawTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignRawTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignRawTransactionResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignRawTransactionResponse {
    fn default() -> &'a SignRawTransactionResponse {
        <SignRawTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignRawTransactionResponse {
    pub fn new() -> SignRawTransactionResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SignRawTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignRawTransactionResponse {
        SignRawTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SignRawTransactionResponse| { &m.query },
                    |m: &mut SignRawTransactionResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignRawTransactionResponse>(
                    "SignRawTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignRawTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignRawTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignRawTransactionResponse,
        };
        unsafe {
            instance.get(SignRawTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignRawTransactionResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignRawTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignRawTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecodeRawTransactionRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecodeRawTransactionRequest {
    fn default() -> &'a DecodeRawTransactionRequest {
        <DecodeRawTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DecodeRawTransactionRequest {
    pub fn new() -> DecodeRawTransactionRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for DecodeRawTransactionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecodeRawTransactionRequest {
        DecodeRawTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &DecodeRawTransactionRequest| { &m.query },
                    |m: &mut DecodeRawTransactionRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DecodeRawTransactionRequest>(
                    "DecodeRawTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecodeRawTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<DecodeRawTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DecodeRawTransactionRequest,
        };
        unsafe {
            instance.get(DecodeRawTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for DecodeRawTransactionRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecodeRawTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecodeRawTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DecodeRawTransactionResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DecodeRawTransactionResponse {
    fn default() -> &'a DecodeRawTransactionResponse {
        <DecodeRawTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DecodeRawTransactionResponse {
    pub fn new() -> DecodeRawTransactionResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DecodeRawTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DecodeRawTransactionResponse {
        DecodeRawTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &DecodeRawTransactionResponse| { &m.query },
                    |m: &mut DecodeRawTransactionResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DecodeRawTransactionResponse>(
                    "DecodeRawTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DecodeRawTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<DecodeRawTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DecodeRawTransactionResponse,
        };
        unsafe {
            instance.get(DecodeRawTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for DecodeRawTransactionResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DecodeRawTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DecodeRawTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BroadcastRawTransactionRequest {
    // message fields
    pub transaction: ::protobuf::SingularPtrField<super::Wire::TransactionBroadcast>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BroadcastRawTransactionRequest {
    fn default() -> &'a BroadcastRawTransactionRequest {
        <BroadcastRawTransactionRequest as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastRawTransactionRequest {
    pub fn new() -> BroadcastRawTransactionRequest {
        ::std::default::Default::default()
    }

    // .Catalyst.Protocol.Wire.TransactionBroadcast transaction = 1;


    pub fn get_transaction(&self) -> &super::Wire::TransactionBroadcast {
        self.transaction.as_ref().unwrap_or_else(|| super::Wire::TransactionBroadcast::default_instance())
    }
    pub fn clear_transaction(&mut self) {
        self.transaction.clear();
    }

    pub fn has_transaction(&self) -> bool {
        self.transaction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transaction(&mut self, v: super::Wire::TransactionBroadcast) {
        self.transaction = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transaction(&mut self) -> &mut super::Wire::TransactionBroadcast {
        if self.transaction.is_none() {
            self.transaction.set_default();
        }
        self.transaction.as_mut().unwrap()
    }

    // Take field
    pub fn take_transaction(&mut self) -> super::Wire::TransactionBroadcast {
        self.transaction.take().unwrap_or_else(|| super::Wire::TransactionBroadcast::new())
    }
}

impl ::protobuf::Message for BroadcastRawTransactionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.transaction {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transaction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transaction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transaction.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BroadcastRawTransactionRequest {
        BroadcastRawTransactionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Wire::TransactionBroadcast>>(
                    "transaction",
                    |m: &BroadcastRawTransactionRequest| { &m.transaction },
                    |m: &mut BroadcastRawTransactionRequest| { &mut m.transaction },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BroadcastRawTransactionRequest>(
                    "BroadcastRawTransactionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BroadcastRawTransactionRequest {
        static mut instance: ::protobuf::lazy::Lazy<BroadcastRawTransactionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BroadcastRawTransactionRequest,
        };
        unsafe {
            instance.get(BroadcastRawTransactionRequest::new)
        }
    }
}

impl ::protobuf::Clear for BroadcastRawTransactionRequest {
    fn clear(&mut self) {
        self.transaction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BroadcastRawTransactionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastRawTransactionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BroadcastRawTransactionResponse {
    // message fields
    pub response_code: ResponseCode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BroadcastRawTransactionResponse {
    fn default() -> &'a BroadcastRawTransactionResponse {
        <BroadcastRawTransactionResponse as ::protobuf::Message>::default_instance()
    }
}

impl BroadcastRawTransactionResponse {
    pub fn new() -> BroadcastRawTransactionResponse {
        ::std::default::Default::default()
    }

    // .Catalyst.Protocol.Rpc.Node.ResponseCode response_code = 1;


    pub fn get_response_code(&self) -> ResponseCode {
        self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code = ResponseCode::PENDING;
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: ResponseCode) {
        self.response_code = v;
    }
}

impl ::protobuf::Message for BroadcastRawTransactionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.response_code, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.response_code != ResponseCode::PENDING {
            my_size += ::protobuf::rt::enum_size(1, self.response_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.response_code != ResponseCode::PENDING {
            os.write_enum(1, self.response_code.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BroadcastRawTransactionResponse {
        BroadcastRawTransactionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseCode>>(
                    "response_code",
                    |m: &BroadcastRawTransactionResponse| { &m.response_code },
                    |m: &mut BroadcastRawTransactionResponse| { &mut m.response_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BroadcastRawTransactionResponse>(
                    "BroadcastRawTransactionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BroadcastRawTransactionResponse {
        static mut instance: ::protobuf::lazy::Lazy<BroadcastRawTransactionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BroadcastRawTransactionResponse,
        };
        unsafe {
            instance.get(BroadcastRawTransactionResponse::new)
        }
    }
}

impl ::protobuf::Clear for BroadcastRawTransactionResponse {
    fn clear(&mut self) {
        self.response_code = ResponseCode::PENDING;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BroadcastRawTransactionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BroadcastRawTransactionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToRequest {
    fn default() -> &'a SendToRequest {
        <SendToRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendToRequest {
    pub fn new() -> SendToRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SendToRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToRequest {
        SendToRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SendToRequest| { &m.query },
                    |m: &mut SendToRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToRequest>(
                    "SendToRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendToRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToRequest,
        };
        unsafe {
            instance.get(SendToRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendToRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToResponse {
    fn default() -> &'a SendToResponse {
        <SendToResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendToResponse {
    pub fn new() -> SendToResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendToResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToResponse {
        SendToResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SendToResponse| { &m.query },
                    |m: &mut SendToResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToResponse>(
                    "SendToResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendToResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToResponse,
        };
        unsafe {
            instance.get(SendToResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendToResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToFromRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToFromRequest {
    fn default() -> &'a SendToFromRequest {
        <SendToFromRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendToFromRequest {
    pub fn new() -> SendToFromRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SendToFromRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToFromRequest {
        SendToFromRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SendToFromRequest| { &m.query },
                    |m: &mut SendToFromRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToFromRequest>(
                    "SendToFromRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToFromRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendToFromRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToFromRequest,
        };
        unsafe {
            instance.get(SendToFromRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendToFromRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToFromRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToFromRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendToFromResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendToFromResponse {
    fn default() -> &'a SendToFromResponse {
        <SendToFromResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendToFromResponse {
    pub fn new() -> SendToFromResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendToFromResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendToFromResponse {
        SendToFromResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SendToFromResponse| { &m.query },
                    |m: &mut SendToFromResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendToFromResponse>(
                    "SendToFromResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendToFromResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendToFromResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendToFromResponse,
        };
        unsafe {
            instance.get(SendToFromResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendToFromResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendToFromResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendToFromResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyRequest {
    fn default() -> &'a SendManyRequest {
        <SendManyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendManyRequest {
    pub fn new() -> SendManyRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SendManyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyRequest {
        SendManyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SendManyRequest| { &m.query },
                    |m: &mut SendManyRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyRequest>(
                    "SendManyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendManyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyRequest,
        };
        unsafe {
            instance.get(SendManyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendManyRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendManyResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendManyResponse {
    fn default() -> &'a SendManyResponse {
        <SendManyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendManyResponse {
    pub fn new() -> SendManyResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendManyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendManyResponse {
        SendManyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SendManyResponse| { &m.query },
                    |m: &mut SendManyResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendManyResponse>(
                    "SendManyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendManyResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendManyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendManyResponse,
        };
        unsafe {
            instance.get(SendManyResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendManyResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendManyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendManyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendFromManyRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendFromManyRequest {
    fn default() -> &'a SendFromManyRequest {
        <SendFromManyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendFromManyRequest {
    pub fn new() -> SendFromManyRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SendFromManyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendFromManyRequest {
        SendFromManyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SendFromManyRequest| { &m.query },
                    |m: &mut SendFromManyRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendFromManyRequest>(
                    "SendFromManyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendFromManyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SendFromManyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendFromManyRequest,
        };
        unsafe {
            instance.get(SendFromManyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SendFromManyRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendFromManyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendFromManyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendFromManyResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendFromManyResponse {
    fn default() -> &'a SendFromManyResponse {
        <SendFromManyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendFromManyResponse {
    pub fn new() -> SendFromManyResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendFromManyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendFromManyResponse {
        SendFromManyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &SendFromManyResponse| { &m.query },
                    |m: &mut SendFromManyResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SendFromManyResponse>(
                    "SendFromManyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SendFromManyResponse {
        static mut instance: ::protobuf::lazy::Lazy<SendFromManyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SendFromManyResponse,
        };
        unsafe {
            instance.get(SendFromManyResponse::new)
        }
    }
}

impl ::protobuf::Clear for SendFromManyResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendFromManyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendFromManyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddNodeRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddNodeRequest {
    fn default() -> &'a AddNodeRequest {
        <AddNodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeRequest {
    pub fn new() -> AddNodeRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for AddNodeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddNodeRequest {
        AddNodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &AddNodeRequest| { &m.query },
                    |m: &mut AddNodeRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddNodeRequest>(
                    "AddNodeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddNodeRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddNodeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddNodeRequest,
        };
        unsafe {
            instance.get(AddNodeRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddNodeRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddNodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddNodeResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddNodeResponse {
    fn default() -> &'a AddNodeResponse {
        <AddNodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddNodeResponse {
    pub fn new() -> AddNodeResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddNodeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddNodeResponse {
        AddNodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &AddNodeResponse| { &m.query },
                    |m: &mut AddNodeResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddNodeResponse>(
                    "AddNodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddNodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddNodeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddNodeResponse,
        };
        unsafe {
            instance.get(AddNodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddNodeResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddNodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddNodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerListRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerListRequest {
    fn default() -> &'a GetPeerListRequest {
        <GetPeerListRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerListRequest {
    pub fn new() -> GetPeerListRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetPeerListRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerListRequest {
        GetPeerListRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerListRequest>(
                    "GetPeerListRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerListRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerListRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerListRequest,
        };
        unsafe {
            instance.get(GetPeerListRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerListRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerListRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerListResponse {
    // message fields
    pub peers: ::protobuf::RepeatedField<super::Peer::PeerId>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerListResponse {
    fn default() -> &'a GetPeerListResponse {
        <GetPeerListResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerListResponse {
    pub fn new() -> GetPeerListResponse {
        ::std::default::Default::default()
    }

    // repeated .Catalyst.Protocol.Peer.PeerId peers = 1;


    pub fn get_peers(&self) -> &[super::Peer::PeerId] {
        &self.peers
    }
    pub fn clear_peers(&mut self) {
        self.peers.clear();
    }

    // Param is passed by value, moved
    pub fn set_peers(&mut self, v: ::protobuf::RepeatedField<super::Peer::PeerId>) {
        self.peers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peers(&mut self) -> &mut ::protobuf::RepeatedField<super::Peer::PeerId> {
        &mut self.peers
    }

    // Take field
    pub fn take_peers(&mut self) -> ::protobuf::RepeatedField<super::Peer::PeerId> {
        ::std::mem::replace(&mut self.peers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeerListResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerListResponse {
        GetPeerListResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Peer::PeerId>>(
                    "peers",
                    |m: &GetPeerListResponse| { &m.peers },
                    |m: &mut GetPeerListResponse| { &mut m.peers },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerListResponse>(
                    "GetPeerListResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerListResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerListResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerListResponse,
        };
        unsafe {
            instance.get(GetPeerListResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerListResponse {
    fn clear(&mut self) {
        self.peers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerListResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerReputationRequest {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub ip: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerReputationRequest {
    fn default() -> &'a GetPeerReputationRequest {
        <GetPeerReputationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerReputationRequest {
    pub fn new() -> GetPeerReputationRequest {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes ip = 2;


    pub fn get_ip(&self) -> &[u8] {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ip, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetPeerReputationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.ip.is_empty() {
            os.write_bytes(2, &self.ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerReputationRequest {
        GetPeerReputationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &GetPeerReputationRequest| { &m.public_key },
                    |m: &mut GetPeerReputationRequest| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ip",
                    |m: &GetPeerReputationRequest| { &m.ip },
                    |m: &mut GetPeerReputationRequest| { &mut m.ip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerReputationRequest>(
                    "GetPeerReputationRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerReputationRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerReputationRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerReputationRequest,
        };
        unsafe {
            instance.get(GetPeerReputationRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerReputationRequest {
    fn clear(&mut self) {
        self.public_key.clear();
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerReputationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerReputationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerReputationResponse {
    // message fields
    pub reputation: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerReputationResponse {
    fn default() -> &'a GetPeerReputationResponse {
        <GetPeerReputationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerReputationResponse {
    pub fn new() -> GetPeerReputationResponse {
        ::std::default::Default::default()
    }

    // int32 reputation = 1;


    pub fn get_reputation(&self) -> i32 {
        self.reputation
    }
    pub fn clear_reputation(&mut self) {
        self.reputation = 0;
    }

    // Param is passed by value, moved
    pub fn set_reputation(&mut self, v: i32) {
        self.reputation = v;
    }
}

impl ::protobuf::Message for GetPeerReputationResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reputation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.reputation != 0 {
            my_size += ::protobuf::rt::value_size(1, self.reputation, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.reputation != 0 {
            os.write_int32(1, self.reputation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerReputationResponse {
        GetPeerReputationResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "reputation",
                    |m: &GetPeerReputationResponse| { &m.reputation },
                    |m: &mut GetPeerReputationResponse| { &mut m.reputation },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerReputationResponse>(
                    "GetPeerReputationResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerReputationResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerReputationResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerReputationResponse,
        };
        unsafe {
            instance.get(GetPeerReputationResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerReputationResponse {
    fn clear(&mut self) {
        self.reputation = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerReputationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerReputationResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPeerBlacklistRequest {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub ip: ::std::vec::Vec<u8>,
    pub blacklist: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPeerBlacklistRequest {
    fn default() -> &'a SetPeerBlacklistRequest {
        <SetPeerBlacklistRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPeerBlacklistRequest {
    pub fn new() -> SetPeerBlacklistRequest {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes ip = 2;


    pub fn get_ip(&self) -> &[u8] {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ip, ::std::vec::Vec::new())
    }

    // bool blacklist = 3;


    pub fn get_blacklist(&self) -> bool {
        self.blacklist
    }
    pub fn clear_blacklist(&mut self) {
        self.blacklist = false;
    }

    // Param is passed by value, moved
    pub fn set_blacklist(&mut self, v: bool) {
        self.blacklist = v;
    }
}

impl ::protobuf::Message for SetPeerBlacklistRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blacklist = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ip);
        }
        if self.blacklist != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.ip.is_empty() {
            os.write_bytes(2, &self.ip)?;
        }
        if self.blacklist != false {
            os.write_bool(3, self.blacklist)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPeerBlacklistRequest {
        SetPeerBlacklistRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &SetPeerBlacklistRequest| { &m.public_key },
                    |m: &mut SetPeerBlacklistRequest| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ip",
                    |m: &SetPeerBlacklistRequest| { &m.ip },
                    |m: &mut SetPeerBlacklistRequest| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blacklist",
                    |m: &SetPeerBlacklistRequest| { &m.blacklist },
                    |m: &mut SetPeerBlacklistRequest| { &mut m.blacklist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPeerBlacklistRequest>(
                    "SetPeerBlacklistRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPeerBlacklistRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetPeerBlacklistRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPeerBlacklistRequest,
        };
        unsafe {
            instance.get(SetPeerBlacklistRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetPeerBlacklistRequest {
    fn clear(&mut self) {
        self.public_key.clear();
        self.ip.clear();
        self.blacklist = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPeerBlacklistRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPeerBlacklistRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPeerBlacklistResponse {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub ip: ::std::vec::Vec<u8>,
    pub blacklist: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPeerBlacklistResponse {
    fn default() -> &'a SetPeerBlacklistResponse {
        <SetPeerBlacklistResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPeerBlacklistResponse {
    pub fn new() -> SetPeerBlacklistResponse {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes ip = 2;


    pub fn get_ip(&self) -> &[u8] {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ip, ::std::vec::Vec::new())
    }

    // bool blacklist = 3;


    pub fn get_blacklist(&self) -> bool {
        self.blacklist
    }
    pub fn clear_blacklist(&mut self) {
        self.blacklist = false;
    }

    // Param is passed by value, moved
    pub fn set_blacklist(&mut self, v: bool) {
        self.blacklist = v;
    }
}

impl ::protobuf::Message for SetPeerBlacklistResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blacklist = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ip);
        }
        if self.blacklist != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.ip.is_empty() {
            os.write_bytes(2, &self.ip)?;
        }
        if self.blacklist != false {
            os.write_bool(3, self.blacklist)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPeerBlacklistResponse {
        SetPeerBlacklistResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &SetPeerBlacklistResponse| { &m.public_key },
                    |m: &mut SetPeerBlacklistResponse| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ip",
                    |m: &SetPeerBlacklistResponse| { &m.ip },
                    |m: &mut SetPeerBlacklistResponse| { &mut m.ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "blacklist",
                    |m: &SetPeerBlacklistResponse| { &m.blacklist },
                    |m: &mut SetPeerBlacklistResponse| { &mut m.blacklist },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPeerBlacklistResponse>(
                    "SetPeerBlacklistResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPeerBlacklistResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetPeerBlacklistResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPeerBlacklistResponse,
        };
        unsafe {
            instance.get(SetPeerBlacklistResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetPeerBlacklistResponse {
    fn clear(&mut self) {
        self.public_key.clear();
        self.ip.clear();
        self.blacklist = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPeerBlacklistResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPeerBlacklistResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerInfoRequest {
    // message fields
    pub public_key: ::std::vec::Vec<u8>,
    pub ip: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerInfoRequest {
    fn default() -> &'a GetPeerInfoRequest {
        <GetPeerInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerInfoRequest {
    pub fn new() -> GetPeerInfoRequest {
        ::std::default::Default::default()
    }

    // bytes public_key = 1;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes ip = 2;


    pub fn get_ip(&self) -> &[u8] {
        &self.ip
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ip
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ip, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetPeerInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.public_key);
        }
        if !self.ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.ip);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.public_key.is_empty() {
            os.write_bytes(1, &self.public_key)?;
        }
        if !self.ip.is_empty() {
            os.write_bytes(2, &self.ip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerInfoRequest {
        GetPeerInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &GetPeerInfoRequest| { &m.public_key },
                    |m: &mut GetPeerInfoRequest| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ip",
                    |m: &GetPeerInfoRequest| { &m.ip },
                    |m: &mut GetPeerInfoRequest| { &mut m.ip },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerInfoRequest>(
                    "GetPeerInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerInfoRequest,
        };
        unsafe {
            instance.get(GetPeerInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerInfoRequest {
    fn clear(&mut self) {
        self.public_key.clear();
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerInfoResponse {
    // message fields
    pub peer_info: ::protobuf::RepeatedField<super::Peer::PeerInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerInfoResponse {
    fn default() -> &'a GetPeerInfoResponse {
        <GetPeerInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerInfoResponse {
    pub fn new() -> GetPeerInfoResponse {
        ::std::default::Default::default()
    }

    // repeated .Catalyst.Protocol.Peer.PeerInfo peer_info = 1;


    pub fn get_peer_info(&self) -> &[super::Peer::PeerInfo] {
        &self.peer_info
    }
    pub fn clear_peer_info(&mut self) {
        self.peer_info.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_info(&mut self, v: ::protobuf::RepeatedField<super::Peer::PeerInfo>) {
        self.peer_info = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peer_info(&mut self) -> &mut ::protobuf::RepeatedField<super::Peer::PeerInfo> {
        &mut self.peer_info
    }

    // Take field
    pub fn take_peer_info(&mut self) -> ::protobuf::RepeatedField<super::Peer::PeerInfo> {
        ::std::mem::replace(&mut self.peer_info, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetPeerInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.peer_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.peer_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.peer_info {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.peer_info {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerInfoResponse {
        GetPeerInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Peer::PeerInfo>>(
                    "peer_info",
                    |m: &GetPeerInfoResponse| { &m.peer_info },
                    |m: &mut GetPeerInfoResponse| { &mut m.peer_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerInfoResponse>(
                    "GetPeerInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerInfoResponse,
        };
        unsafe {
            instance.get(GetPeerInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerInfoResponse {
    fn clear(&mut self) {
        self.peer_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectionCountRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionCountRequest {
    fn default() -> &'a GetConnectionCountRequest {
        <GetConnectionCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionCountRequest {
    pub fn new() -> GetConnectionCountRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for GetConnectionCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionCountRequest {
        GetConnectionCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &GetConnectionCountRequest| { &m.query },
                    |m: &mut GetConnectionCountRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetConnectionCountRequest>(
                    "GetConnectionCountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetConnectionCountRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetConnectionCountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetConnectionCountRequest,
        };
        unsafe {
            instance.get(GetConnectionCountRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetConnectionCountRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetConnectionCountResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetConnectionCountResponse {
    fn default() -> &'a GetConnectionCountResponse {
        <GetConnectionCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetConnectionCountResponse {
    pub fn new() -> GetConnectionCountResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetConnectionCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetConnectionCountResponse {
        GetConnectionCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &GetConnectionCountResponse| { &m.query },
                    |m: &mut GetConnectionCountResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetConnectionCountResponse>(
                    "GetConnectionCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetConnectionCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetConnectionCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetConnectionCountResponse,
        };
        unsafe {
            instance.get(GetConnectionCountResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetConnectionCountResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetConnectionCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetConnectionCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeltaRequest {
    // message fields
    pub delta_dfs_hash: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeltaRequest {
    fn default() -> &'a GetDeltaRequest {
        <GetDeltaRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeltaRequest {
    pub fn new() -> GetDeltaRequest {
        ::std::default::Default::default()
    }

    // bytes delta_dfs_hash = 1;


    pub fn get_delta_dfs_hash(&self) -> &[u8] {
        &self.delta_dfs_hash
    }
    pub fn clear_delta_dfs_hash(&mut self) {
        self.delta_dfs_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_delta_dfs_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.delta_dfs_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta_dfs_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.delta_dfs_hash
    }

    // Take field
    pub fn take_delta_dfs_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.delta_dfs_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetDeltaRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.delta_dfs_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.delta_dfs_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.delta_dfs_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.delta_dfs_hash.is_empty() {
            os.write_bytes(1, &self.delta_dfs_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeltaRequest {
        GetDeltaRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "delta_dfs_hash",
                    |m: &GetDeltaRequest| { &m.delta_dfs_hash },
                    |m: &mut GetDeltaRequest| { &mut m.delta_dfs_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeltaRequest>(
                    "GetDeltaRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeltaRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetDeltaRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeltaRequest,
        };
        unsafe {
            instance.get(GetDeltaRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetDeltaRequest {
    fn clear(&mut self) {
        self.delta_dfs_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeltaRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeltaRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeltaResponse {
    // message fields
    pub delta: ::protobuf::SingularPtrField<super::Deltas::Delta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeltaResponse {
    fn default() -> &'a GetDeltaResponse {
        <GetDeltaResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDeltaResponse {
    pub fn new() -> GetDeltaResponse {
        ::std::default::Default::default()
    }

    // .Catalyst.Protocol.Deltas.Delta delta = 1;


    pub fn get_delta(&self) -> &super::Deltas::Delta {
        self.delta.as_ref().unwrap_or_else(|| super::Deltas::Delta::default_instance())
    }
    pub fn clear_delta(&mut self) {
        self.delta.clear();
    }

    pub fn has_delta(&self) -> bool {
        self.delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: super::Deltas::Delta) {
        self.delta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_delta(&mut self) -> &mut super::Deltas::Delta {
        if self.delta.is_none() {
            self.delta.set_default();
        }
        self.delta.as_mut().unwrap()
    }

    // Take field
    pub fn take_delta(&mut self) -> super::Deltas::Delta {
        self.delta.take().unwrap_or_else(|| super::Deltas::Delta::new())
    }
}

impl ::protobuf::Message for GetDeltaResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.delta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.delta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.delta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.delta.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeltaResponse {
        GetDeltaResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Deltas::Delta>>(
                    "delta",
                    |m: &GetDeltaResponse| { &m.delta },
                    |m: &mut GetDeltaResponse| { &mut m.delta },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetDeltaResponse>(
                    "GetDeltaResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetDeltaResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetDeltaResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetDeltaResponse,
        };
        unsafe {
            instance.get(GetDeltaResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetDeltaResponse {
    fn clear(&mut self) {
        self.delta.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeltaResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeltaResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMempoolRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMempoolRequest {
    fn default() -> &'a GetMempoolRequest {
        <GetMempoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetMempoolRequest {
    pub fn new() -> GetMempoolRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for GetMempoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMempoolRequest {
        GetMempoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &GetMempoolRequest| { &m.query },
                    |m: &mut GetMempoolRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetMempoolRequest>(
                    "GetMempoolRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMempoolRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetMempoolRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetMempoolRequest,
        };
        unsafe {
            instance.get(GetMempoolRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetMempoolRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMempoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMempoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetMempoolResponse {
    // message fields
    pub transactions: ::protobuf::RepeatedField<super::Transaction::PublicEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetMempoolResponse {
    fn default() -> &'a GetMempoolResponse {
        <GetMempoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetMempoolResponse {
    pub fn new() -> GetMempoolResponse {
        ::std::default::Default::default()
    }

    // repeated .Catalyst.Protocol.Transaction.PublicEntry transactions = 1;


    pub fn get_transactions(&self) -> &[super::Transaction::PublicEntry] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<super::Transaction::PublicEntry>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<super::Transaction::PublicEntry> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<super::Transaction::PublicEntry> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetMempoolResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetMempoolResponse {
        GetMempoolResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Transaction::PublicEntry>>(
                    "transactions",
                    |m: &GetMempoolResponse| { &m.transactions },
                    |m: &mut GetMempoolResponse| { &mut m.transactions },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetMempoolResponse>(
                    "GetMempoolResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetMempoolResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetMempoolResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetMempoolResponse,
        };
        unsafe {
            instance.get(GetMempoolResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetMempoolResponse {
    fn clear(&mut self) {
        self.transactions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetMempoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetMempoolResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageRequest {
    // message fields
    pub message: ::std::vec::Vec<u8>,
    pub key_id: ::std::string::String,
    pub signing_context: ::protobuf::SingularPtrField<super::Cryptography::SigningContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageRequest {
    fn default() -> &'a SignMessageRequest {
        <SignMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageRequest {
    pub fn new() -> SignMessageRequest {
        ::std::default::Default::default()
    }

    // bytes message = 1;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }

    // string key_id = 2;


    pub fn get_key_id(&self) -> &str {
        &self.key_id
    }
    pub fn clear_key_id(&mut self) {
        self.key_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_id(&mut self, v: ::std::string::String) {
        self.key_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_id(&mut self) -> &mut ::std::string::String {
        &mut self.key_id
    }

    // Take field
    pub fn take_key_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_id, ::std::string::String::new())
    }

    // .Catalyst.Protocol.Cryptography.SigningContext signing_context = 3;


    pub fn get_signing_context(&self) -> &super::Cryptography::SigningContext {
        self.signing_context.as_ref().unwrap_or_else(|| super::Cryptography::SigningContext::default_instance())
    }
    pub fn clear_signing_context(&mut self) {
        self.signing_context.clear();
    }

    pub fn has_signing_context(&self) -> bool {
        self.signing_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signing_context(&mut self, v: super::Cryptography::SigningContext) {
        self.signing_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signing_context(&mut self) -> &mut super::Cryptography::SigningContext {
        if self.signing_context.is_none() {
            self.signing_context.set_default();
        }
        self.signing_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_signing_context(&mut self) -> super::Cryptography::SigningContext {
        self.signing_context.take().unwrap_or_else(|| super::Cryptography::SigningContext::new())
    }
}

impl ::protobuf::Message for SignMessageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.signing_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signing_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.message);
        }
        if !self.key_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.key_id);
        }
        if let Some(ref v) = self.signing_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.message.is_empty() {
            os.write_bytes(1, &self.message)?;
        }
        if !self.key_id.is_empty() {
            os.write_string(2, &self.key_id)?;
        }
        if let Some(ref v) = self.signing_context.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageRequest {
        SignMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &SignMessageRequest| { &m.message },
                    |m: &mut SignMessageRequest| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "key_id",
                    |m: &SignMessageRequest| { &m.key_id },
                    |m: &mut SignMessageRequest| { &mut m.key_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Cryptography::SigningContext>>(
                    "signing_context",
                    |m: &SignMessageRequest| { &m.signing_context },
                    |m: &mut SignMessageRequest| { &mut m.signing_context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageRequest>(
                    "SignMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageRequest,
        };
        unsafe {
            instance.get(SignMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageRequest {
    fn clear(&mut self) {
        self.message.clear();
        self.key_id.clear();
        self.signing_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignMessageResponse {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    pub public_key: ::std::vec::Vec<u8>,
    pub original_message: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignMessageResponse {
    fn default() -> &'a SignMessageResponse {
        <SignMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl SignMessageResponse {
    pub fn new() -> SignMessageResponse {
        ::std::default::Default::default()
    }

    // bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes public_key = 2;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes original_message = 3;


    pub fn get_original_message(&self) -> &[u8] {
        &self.original_message
    }
    pub fn clear_original_message(&mut self) {
        self.original_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_original_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.original_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.original_message
    }

    // Take field
    pub fn take_original_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.original_message, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.original_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.public_key);
        }
        if !self.original_message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.original_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(1, &self.signature)?;
        }
        if !self.public_key.is_empty() {
            os.write_bytes(2, &self.public_key)?;
        }
        if !self.original_message.is_empty() {
            os.write_bytes(3, &self.original_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignMessageResponse {
        SignMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &SignMessageResponse| { &m.signature },
                    |m: &mut SignMessageResponse| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &SignMessageResponse| { &m.public_key },
                    |m: &mut SignMessageResponse| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "original_message",
                    |m: &SignMessageResponse| { &m.original_message },
                    |m: &mut SignMessageResponse| { &mut m.original_message },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignMessageResponse>(
                    "SignMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<SignMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignMessageResponse,
        };
        unsafe {
            instance.get(SignMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for SignMessageResponse {
    fn clear(&mut self) {
        self.signature.clear();
        self.public_key.clear();
        self.original_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageRequest {
    // message fields
    pub signature: ::std::vec::Vec<u8>,
    pub public_key: ::std::vec::Vec<u8>,
    pub message: ::std::vec::Vec<u8>,
    pub signing_context: ::protobuf::SingularPtrField<super::Cryptography::SigningContext>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageRequest {
    fn default() -> &'a VerifyMessageRequest {
        <VerifyMessageRequest as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageRequest {
    pub fn new() -> VerifyMessageRequest {
        ::std::default::Default::default()
    }

    // bytes signature = 1;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }

    // bytes public_key = 2;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }

    // bytes message = 3;


    pub fn get_message(&self) -> &[u8] {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.message, ::std::vec::Vec::new())
    }

    // .Catalyst.Protocol.Cryptography.SigningContext signing_context = 4;


    pub fn get_signing_context(&self) -> &super::Cryptography::SigningContext {
        self.signing_context.as_ref().unwrap_or_else(|| super::Cryptography::SigningContext::default_instance())
    }
    pub fn clear_signing_context(&mut self) {
        self.signing_context.clear();
    }

    pub fn has_signing_context(&self) -> bool {
        self.signing_context.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signing_context(&mut self, v: super::Cryptography::SigningContext) {
        self.signing_context = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signing_context(&mut self) -> &mut super::Cryptography::SigningContext {
        if self.signing_context.is_none() {
            self.signing_context.set_default();
        }
        self.signing_context.as_mut().unwrap()
    }

    // Take field
    pub fn take_signing_context(&mut self) -> super::Cryptography::SigningContext {
        self.signing_context.take().unwrap_or_else(|| super::Cryptography::SigningContext::new())
    }
}

impl ::protobuf::Message for VerifyMessageRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.signing_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signing_context)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.signature);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.public_key);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        if let Some(ref v) = self.signing_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.signature.is_empty() {
            os.write_bytes(1, &self.signature)?;
        }
        if !self.public_key.is_empty() {
            os.write_bytes(2, &self.public_key)?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        if let Some(ref v) = self.signing_context.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageRequest {
        VerifyMessageRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &VerifyMessageRequest| { &m.signature },
                    |m: &mut VerifyMessageRequest| { &mut m.signature },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &VerifyMessageRequest| { &m.public_key },
                    |m: &mut VerifyMessageRequest| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "message",
                    |m: &VerifyMessageRequest| { &m.message },
                    |m: &mut VerifyMessageRequest| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Cryptography::SigningContext>>(
                    "signing_context",
                    |m: &VerifyMessageRequest| { &m.signing_context },
                    |m: &mut VerifyMessageRequest| { &mut m.signing_context },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageRequest>(
                    "VerifyMessageRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageRequest {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageRequest,
        };
        unsafe {
            instance.get(VerifyMessageRequest::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageRequest {
    fn clear(&mut self) {
        self.signature.clear();
        self.public_key.clear();
        self.message.clear();
        self.signing_context.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerifyMessageResponse {
    // message fields
    pub is_signed_by_key: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerifyMessageResponse {
    fn default() -> &'a VerifyMessageResponse {
        <VerifyMessageResponse as ::protobuf::Message>::default_instance()
    }
}

impl VerifyMessageResponse {
    pub fn new() -> VerifyMessageResponse {
        ::std::default::Default::default()
    }

    // bool is_signed_by_key = 1;


    pub fn get_is_signed_by_key(&self) -> bool {
        self.is_signed_by_key
    }
    pub fn clear_is_signed_by_key(&mut self) {
        self.is_signed_by_key = false;
    }

    // Param is passed by value, moved
    pub fn set_is_signed_by_key(&mut self, v: bool) {
        self.is_signed_by_key = v;
    }
}

impl ::protobuf::Message for VerifyMessageResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_signed_by_key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_signed_by_key != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_signed_by_key != false {
            os.write_bool(1, self.is_signed_by_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerifyMessageResponse {
        VerifyMessageResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_signed_by_key",
                    |m: &VerifyMessageResponse| { &m.is_signed_by_key },
                    |m: &mut VerifyMessageResponse| { &mut m.is_signed_by_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VerifyMessageResponse>(
                    "VerifyMessageResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VerifyMessageResponse {
        static mut instance: ::protobuf::lazy::Lazy<VerifyMessageResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VerifyMessageResponse,
        };
        unsafe {
            instance.get(VerifyMessageResponse::new)
        }
    }
}

impl ::protobuf::Clear for VerifyMessageResponse {
    fn clear(&mut self) {
        self.is_signed_by_key = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerifyMessageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerifyMessageResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceStatusRequest {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceStatusRequest {
    fn default() -> &'a ServiceStatusRequest {
        <ServiceStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl ServiceStatusRequest {
    pub fn new() -> ServiceStatusRequest {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for ServiceStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceStatusRequest {
        ServiceStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &ServiceStatusRequest| { &m.query },
                    |m: &mut ServiceStatusRequest| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceStatusRequest>(
                    "ServiceStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<ServiceStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceStatusRequest,
        };
        unsafe {
            instance.get(ServiceStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for ServiceStatusRequest {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceStatusResponse {
    // message fields
    pub query: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceStatusResponse {
    fn default() -> &'a ServiceStatusResponse {
        <ServiceStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl ServiceStatusResponse {
    pub fn new() -> ServiceStatusResponse {
        ::std::default::Default::default()
    }

    // string query = 1;


    pub fn get_query(&self) -> &str {
        &self.query
    }
    pub fn clear_query(&mut self) {
        self.query.clear();
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: ::std::string::String) {
        self.query = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_query(&mut self) -> &mut ::std::string::String {
        &mut self.query
    }

    // Take field
    pub fn take_query(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.query, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServiceStatusResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.query)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.query.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.query);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.query.is_empty() {
            os.write_string(1, &self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceStatusResponse {
        ServiceStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "query",
                    |m: &ServiceStatusResponse| { &m.query },
                    |m: &mut ServiceStatusResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ServiceStatusResponse>(
                    "ServiceStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ServiceStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<ServiceStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ServiceStatusResponse,
        };
        unsafe {
            instance.get(ServiceStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for ServiceStatusResponse {
    fn clear(&mut self) {
        self.query.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddFileToDfsRequest {
    // message fields
    pub file_size: u64,
    pub file_name: ::std::string::String,
    pub node: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddFileToDfsRequest {
    fn default() -> &'a AddFileToDfsRequest {
        <AddFileToDfsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AddFileToDfsRequest {
    pub fn new() -> AddFileToDfsRequest {
        ::std::default::Default::default()
    }

    // uint64 file_size = 1;


    pub fn get_file_size(&self) -> u64 {
        self.file_size
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = v;
    }

    // string file_name = 2;


    pub fn get_file_name(&self) -> &str {
        &self.file_name
    }
    pub fn clear_file_name(&mut self) {
        self.file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        &mut self.file_name
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_name, ::std::string::String::new())
    }

    // string node = 3;


    pub fn get_node(&self) -> &str {
        &self.node
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::std::string::String) {
        self.node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut ::std::string::String {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddFileToDfsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.file_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.file_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.file_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.file_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.file_name);
        }
        if !self.node.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.node);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.file_size != 0 {
            os.write_uint64(1, self.file_size)?;
        }
        if !self.file_name.is_empty() {
            os.write_string(2, &self.file_name)?;
        }
        if !self.node.is_empty() {
            os.write_string(3, &self.node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddFileToDfsRequest {
        AddFileToDfsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "file_size",
                    |m: &AddFileToDfsRequest| { &m.file_size },
                    |m: &mut AddFileToDfsRequest| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_name",
                    |m: &AddFileToDfsRequest| { &m.file_name },
                    |m: &mut AddFileToDfsRequest| { &mut m.file_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "node",
                    |m: &AddFileToDfsRequest| { &m.node },
                    |m: &mut AddFileToDfsRequest| { &mut m.node },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddFileToDfsRequest>(
                    "AddFileToDfsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddFileToDfsRequest {
        static mut instance: ::protobuf::lazy::Lazy<AddFileToDfsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddFileToDfsRequest,
        };
        unsafe {
            instance.get(AddFileToDfsRequest::new)
        }
    }
}

impl ::protobuf::Clear for AddFileToDfsRequest {
    fn clear(&mut self) {
        self.file_size = 0;
        self.file_name.clear();
        self.node.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddFileToDfsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddFileToDfsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddFileToDfsResponse {
    // message fields
    pub response_code: ::std::vec::Vec<u8>,
    pub dfs_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddFileToDfsResponse {
    fn default() -> &'a AddFileToDfsResponse {
        <AddFileToDfsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AddFileToDfsResponse {
    pub fn new() -> AddFileToDfsResponse {
        ::std::default::Default::default()
    }

    // bytes response_code = 1;


    pub fn get_response_code(&self) -> &[u8] {
        &self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.response_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.response_code
    }

    // Take field
    pub fn take_response_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.response_code, ::std::vec::Vec::new())
    }

    // string dfs_hash = 2;


    pub fn get_dfs_hash(&self) -> &str {
        &self.dfs_hash
    }
    pub fn clear_dfs_hash(&mut self) {
        self.dfs_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_dfs_hash(&mut self, v: ::std::string::String) {
        self.dfs_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dfs_hash(&mut self) -> &mut ::std::string::String {
        &mut self.dfs_hash
    }

    // Take field
    pub fn take_dfs_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dfs_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AddFileToDfsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.response_code)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dfs_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.response_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.response_code);
        }
        if !self.dfs_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.dfs_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.response_code.is_empty() {
            os.write_bytes(1, &self.response_code)?;
        }
        if !self.dfs_hash.is_empty() {
            os.write_string(2, &self.dfs_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddFileToDfsResponse {
        AddFileToDfsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "response_code",
                    |m: &AddFileToDfsResponse| { &m.response_code },
                    |m: &mut AddFileToDfsResponse| { &mut m.response_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dfs_hash",
                    |m: &AddFileToDfsResponse| { &m.dfs_hash },
                    |m: &mut AddFileToDfsResponse| { &mut m.dfs_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AddFileToDfsResponse>(
                    "AddFileToDfsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddFileToDfsResponse {
        static mut instance: ::protobuf::lazy::Lazy<AddFileToDfsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AddFileToDfsResponse,
        };
        unsafe {
            instance.get(AddFileToDfsResponse::new)
        }
    }
}

impl ::protobuf::Clear for AddFileToDfsResponse {
    fn clear(&mut self) {
        self.response_code.clear();
        self.dfs_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddFileToDfsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddFileToDfsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferFileBytesRequest {
    // message fields
    pub chunk_id: u32,
    pub chunk_bytes: ::std::vec::Vec<u8>,
    pub correlation_file_name: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferFileBytesRequest {
    fn default() -> &'a TransferFileBytesRequest {
        <TransferFileBytesRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransferFileBytesRequest {
    pub fn new() -> TransferFileBytesRequest {
        ::std::default::Default::default()
    }

    // uint32 chunk_id = 1;


    pub fn get_chunk_id(&self) -> u32 {
        self.chunk_id
    }
    pub fn clear_chunk_id(&mut self) {
        self.chunk_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_chunk_id(&mut self, v: u32) {
        self.chunk_id = v;
    }

    // bytes chunk_bytes = 2;


    pub fn get_chunk_bytes(&self) -> &[u8] {
        &self.chunk_bytes
    }
    pub fn clear_chunk_bytes(&mut self) {
        self.chunk_bytes.clear();
    }

    // Param is passed by value, moved
    pub fn set_chunk_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.chunk_bytes = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_chunk_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.chunk_bytes
    }

    // Take field
    pub fn take_chunk_bytes(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.chunk_bytes, ::std::vec::Vec::new())
    }

    // bytes correlation_file_name = 3;


    pub fn get_correlation_file_name(&self) -> &[u8] {
        &self.correlation_file_name
    }
    pub fn clear_correlation_file_name(&mut self) {
        self.correlation_file_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_correlation_file_name(&mut self, v: ::std::vec::Vec<u8>) {
        self.correlation_file_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_correlation_file_name(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.correlation_file_name
    }

    // Take field
    pub fn take_correlation_file_name(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.correlation_file_name, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransferFileBytesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.chunk_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.chunk_bytes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.correlation_file_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.chunk_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.chunk_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.chunk_bytes.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.chunk_bytes);
        }
        if !self.correlation_file_name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.correlation_file_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.chunk_id != 0 {
            os.write_uint32(1, self.chunk_id)?;
        }
        if !self.chunk_bytes.is_empty() {
            os.write_bytes(2, &self.chunk_bytes)?;
        }
        if !self.correlation_file_name.is_empty() {
            os.write_bytes(3, &self.correlation_file_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferFileBytesRequest {
        TransferFileBytesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "chunk_id",
                    |m: &TransferFileBytesRequest| { &m.chunk_id },
                    |m: &mut TransferFileBytesRequest| { &mut m.chunk_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "chunk_bytes",
                    |m: &TransferFileBytesRequest| { &m.chunk_bytes },
                    |m: &mut TransferFileBytesRequest| { &mut m.chunk_bytes },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "correlation_file_name",
                    |m: &TransferFileBytesRequest| { &m.correlation_file_name },
                    |m: &mut TransferFileBytesRequest| { &mut m.correlation_file_name },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferFileBytesRequest>(
                    "TransferFileBytesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferFileBytesRequest {
        static mut instance: ::protobuf::lazy::Lazy<TransferFileBytesRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferFileBytesRequest,
        };
        unsafe {
            instance.get(TransferFileBytesRequest::new)
        }
    }
}

impl ::protobuf::Clear for TransferFileBytesRequest {
    fn clear(&mut self) {
        self.chunk_id = 0;
        self.chunk_bytes.clear();
        self.correlation_file_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferFileBytesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferFileBytesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferFileBytesResponse {
    // message fields
    pub response_code: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferFileBytesResponse {
    fn default() -> &'a TransferFileBytesResponse {
        <TransferFileBytesResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferFileBytesResponse {
    pub fn new() -> TransferFileBytesResponse {
        ::std::default::Default::default()
    }

    // bytes response_code = 1;


    pub fn get_response_code(&self) -> &[u8] {
        &self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.response_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.response_code
    }

    // Take field
    pub fn take_response_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.response_code, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TransferFileBytesResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.response_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.response_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.response_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.response_code.is_empty() {
            os.write_bytes(1, &self.response_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferFileBytesResponse {
        TransferFileBytesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "response_code",
                    |m: &TransferFileBytesResponse| { &m.response_code },
                    |m: &mut TransferFileBytesResponse| { &mut m.response_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransferFileBytesResponse>(
                    "TransferFileBytesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransferFileBytesResponse {
        static mut instance: ::protobuf::lazy::Lazy<TransferFileBytesResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransferFileBytesResponse,
        };
        unsafe {
            instance.get(TransferFileBytesResponse::new)
        }
    }
}

impl ::protobuf::Clear for TransferFileBytesResponse {
    fn clear(&mut self) {
        self.response_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferFileBytesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferFileBytesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemovePeerRequest {
    // message fields
    pub peer_ip: ::std::vec::Vec<u8>,
    pub public_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemovePeerRequest {
    fn default() -> &'a RemovePeerRequest {
        <RemovePeerRequest as ::protobuf::Message>::default_instance()
    }
}

impl RemovePeerRequest {
    pub fn new() -> RemovePeerRequest {
        ::std::default::Default::default()
    }

    // bytes peer_ip = 1;


    pub fn get_peer_ip(&self) -> &[u8] {
        &self.peer_ip
    }
    pub fn clear_peer_ip(&mut self) {
        self.peer_ip.clear();
    }

    // Param is passed by value, moved
    pub fn set_peer_ip(&mut self, v: ::std::vec::Vec<u8>) {
        self.peer_ip = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peer_ip(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.peer_ip
    }

    // Take field
    pub fn take_peer_ip(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.peer_ip, ::std::vec::Vec::new())
    }

    // bytes public_key = 2;


    pub fn get_public_key(&self) -> &[u8] {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.public_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RemovePeerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.peer_ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.public_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.peer_ip.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.peer_ip);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.public_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.peer_ip.is_empty() {
            os.write_bytes(1, &self.peer_ip)?;
        }
        if !self.public_key.is_empty() {
            os.write_bytes(2, &self.public_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemovePeerRequest {
        RemovePeerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "peer_ip",
                    |m: &RemovePeerRequest| { &m.peer_ip },
                    |m: &mut RemovePeerRequest| { &mut m.peer_ip },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_key",
                    |m: &RemovePeerRequest| { &m.public_key },
                    |m: &mut RemovePeerRequest| { &mut m.public_key },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemovePeerRequest>(
                    "RemovePeerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemovePeerRequest {
        static mut instance: ::protobuf::lazy::Lazy<RemovePeerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemovePeerRequest,
        };
        unsafe {
            instance.get(RemovePeerRequest::new)
        }
    }
}

impl ::protobuf::Clear for RemovePeerRequest {
    fn clear(&mut self) {
        self.peer_ip.clear();
        self.public_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemovePeerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePeerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RemovePeerResponse {
    // message fields
    pub deleted_count: u32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemovePeerResponse {
    fn default() -> &'a RemovePeerResponse {
        <RemovePeerResponse as ::protobuf::Message>::default_instance()
    }
}

impl RemovePeerResponse {
    pub fn new() -> RemovePeerResponse {
        ::std::default::Default::default()
    }

    // uint32 deleted_count = 1;


    pub fn get_deleted_count(&self) -> u32 {
        self.deleted_count
    }
    pub fn clear_deleted_count(&mut self) {
        self.deleted_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_deleted_count(&mut self, v: u32) {
        self.deleted_count = v;
    }
}

impl ::protobuf::Message for RemovePeerResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.deleted_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.deleted_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.deleted_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.deleted_count != 0 {
            os.write_uint32(1, self.deleted_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemovePeerResponse {
        RemovePeerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "deleted_count",
                    |m: &RemovePeerResponse| { &m.deleted_count },
                    |m: &mut RemovePeerResponse| { &mut m.deleted_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RemovePeerResponse>(
                    "RemovePeerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RemovePeerResponse {
        static mut instance: ::protobuf::lazy::Lazy<RemovePeerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RemovePeerResponse,
        };
        unsafe {
            instance.get(RemovePeerResponse::new)
        }
    }
}

impl ::protobuf::Clear for RemovePeerResponse {
    fn clear(&mut self) {
        self.deleted_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemovePeerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemovePeerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerCountRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerCountRequest {
    fn default() -> &'a GetPeerCountRequest {
        <GetPeerCountRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerCountRequest {
    pub fn new() -> GetPeerCountRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetPeerCountRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerCountRequest {
        GetPeerCountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerCountRequest>(
                    "GetPeerCountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerCountRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerCountRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerCountRequest,
        };
        unsafe {
            instance.get(GetPeerCountRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerCountRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerCountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerCountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetPeerCountResponse {
    // message fields
    pub peer_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetPeerCountResponse {
    fn default() -> &'a GetPeerCountResponse {
        <GetPeerCountResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetPeerCountResponse {
    pub fn new() -> GetPeerCountResponse {
        ::std::default::Default::default()
    }

    // int32 peer_count = 1;


    pub fn get_peer_count(&self) -> i32 {
        self.peer_count
    }
    pub fn clear_peer_count(&mut self) {
        self.peer_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_peer_count(&mut self, v: i32) {
        self.peer_count = v;
    }
}

impl ::protobuf::Message for GetPeerCountResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.peer_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.peer_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.peer_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.peer_count != 0 {
            os.write_int32(1, self.peer_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetPeerCountResponse {
        GetPeerCountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "peer_count",
                    |m: &GetPeerCountResponse| { &m.peer_count },
                    |m: &mut GetPeerCountResponse| { &mut m.peer_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetPeerCountResponse>(
                    "GetPeerCountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetPeerCountResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetPeerCountResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetPeerCountResponse,
        };
        unsafe {
            instance.get(GetPeerCountResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetPeerCountResponse {
    fn clear(&mut self) {
        self.peer_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetPeerCountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetPeerCountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileFromDfsRequest {
    // message fields
    pub dfs_hash: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileFromDfsRequest {
    fn default() -> &'a GetFileFromDfsRequest {
        <GetFileFromDfsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFileFromDfsRequest {
    pub fn new() -> GetFileFromDfsRequest {
        ::std::default::Default::default()
    }

    // string dfs_hash = 1;


    pub fn get_dfs_hash(&self) -> &str {
        &self.dfs_hash
    }
    pub fn clear_dfs_hash(&mut self) {
        self.dfs_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_dfs_hash(&mut self, v: ::std::string::String) {
        self.dfs_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dfs_hash(&mut self) -> &mut ::std::string::String {
        &mut self.dfs_hash
    }

    // Take field
    pub fn take_dfs_hash(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dfs_hash, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetFileFromDfsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dfs_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dfs_hash.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dfs_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dfs_hash.is_empty() {
            os.write_string(1, &self.dfs_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileFromDfsRequest {
        GetFileFromDfsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "dfs_hash",
                    |m: &GetFileFromDfsRequest| { &m.dfs_hash },
                    |m: &mut GetFileFromDfsRequest| { &mut m.dfs_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileFromDfsRequest>(
                    "GetFileFromDfsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileFromDfsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetFileFromDfsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileFromDfsRequest,
        };
        unsafe {
            instance.get(GetFileFromDfsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetFileFromDfsRequest {
    fn clear(&mut self) {
        self.dfs_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileFromDfsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileFromDfsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetFileFromDfsResponse {
    // message fields
    pub file_size: u64,
    pub response_code: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetFileFromDfsResponse {
    fn default() -> &'a GetFileFromDfsResponse {
        <GetFileFromDfsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFileFromDfsResponse {
    pub fn new() -> GetFileFromDfsResponse {
        ::std::default::Default::default()
    }

    // uint64 file_size = 1;


    pub fn get_file_size(&self) -> u64 {
        self.file_size
    }
    pub fn clear_file_size(&mut self) {
        self.file_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u64) {
        self.file_size = v;
    }

    // bytes response_code = 2;


    pub fn get_response_code(&self) -> &[u8] {
        &self.response_code
    }
    pub fn clear_response_code(&mut self) {
        self.response_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.response_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.response_code
    }

    // Take field
    pub fn take_response_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.response_code, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetFileFromDfsResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.file_size = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.response_code)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.file_size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.file_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.response_code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.response_code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.file_size != 0 {
            os.write_uint64(1, self.file_size)?;
        }
        if !self.response_code.is_empty() {
            os.write_bytes(2, &self.response_code)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetFileFromDfsResponse {
        GetFileFromDfsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "file_size",
                    |m: &GetFileFromDfsResponse| { &m.file_size },
                    |m: &mut GetFileFromDfsResponse| { &mut m.file_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "response_code",
                    |m: &GetFileFromDfsResponse| { &m.response_code },
                    |m: &mut GetFileFromDfsResponse| { &mut m.response_code },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetFileFromDfsResponse>(
                    "GetFileFromDfsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetFileFromDfsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetFileFromDfsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetFileFromDfsResponse,
        };
        unsafe {
            instance.get(GetFileFromDfsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetFileFromDfsResponse {
    fn clear(&mut self) {
        self.file_size = 0;
        self.response_code.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetFileFromDfsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFileFromDfsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPeerDataFolderRequest {
    // message fields
    pub data_folder: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPeerDataFolderRequest {
    fn default() -> &'a SetPeerDataFolderRequest {
        <SetPeerDataFolderRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPeerDataFolderRequest {
    pub fn new() -> SetPeerDataFolderRequest {
        ::std::default::Default::default()
    }

    // string data_folder = 1;


    pub fn get_data_folder(&self) -> &str {
        &self.data_folder
    }
    pub fn clear_data_folder(&mut self) {
        self.data_folder.clear();
    }

    // Param is passed by value, moved
    pub fn set_data_folder(&mut self, v: ::std::string::String) {
        self.data_folder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_folder(&mut self) -> &mut ::std::string::String {
        &mut self.data_folder
    }

    // Take field
    pub fn take_data_folder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.data_folder, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetPeerDataFolderRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.data_folder)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.data_folder.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.data_folder);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.data_folder.is_empty() {
            os.write_string(1, &self.data_folder)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPeerDataFolderRequest {
        SetPeerDataFolderRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "data_folder",
                    |m: &SetPeerDataFolderRequest| { &m.data_folder },
                    |m: &mut SetPeerDataFolderRequest| { &mut m.data_folder },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPeerDataFolderRequest>(
                    "SetPeerDataFolderRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPeerDataFolderRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetPeerDataFolderRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPeerDataFolderRequest,
        };
        unsafe {
            instance.get(SetPeerDataFolderRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetPeerDataFolderRequest {
    fn clear(&mut self) {
        self.data_folder.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPeerDataFolderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPeerDataFolderRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPeerDataFolderResponse {
    // message fields
    pub query: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPeerDataFolderResponse {
    fn default() -> &'a SetPeerDataFolderResponse {
        <SetPeerDataFolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPeerDataFolderResponse {
    pub fn new() -> SetPeerDataFolderResponse {
        ::std::default::Default::default()
    }

    // bool query = 1;


    pub fn get_query(&self) -> bool {
        self.query
    }
    pub fn clear_query(&mut self) {
        self.query = false;
    }

    // Param is passed by value, moved
    pub fn set_query(&mut self, v: bool) {
        self.query = v;
    }
}

impl ::protobuf::Message for SetPeerDataFolderResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.query = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.query != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.query != false {
            os.write_bool(1, self.query)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPeerDataFolderResponse {
        SetPeerDataFolderResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "query",
                    |m: &SetPeerDataFolderResponse| { &m.query },
                    |m: &mut SetPeerDataFolderResponse| { &mut m.query },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPeerDataFolderResponse>(
                    "SetPeerDataFolderResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPeerDataFolderResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetPeerDataFolderResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPeerDataFolderResponse,
        };
        unsafe {
            instance.get(SetPeerDataFolderResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetPeerDataFolderResponse {
    fn clear(&mut self) {
        self.query = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPeerDataFolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPeerDataFolderResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseCode {
    PENDING = 0,
    SUCCESSFUL = 1,
    ERROR = 2,
    FINISHED = 3,
    EXPIRED = 4,
    FAILED = 5,
}

impl ::protobuf::ProtobufEnum for ResponseCode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseCode> {
        match value {
            0 => ::std::option::Option::Some(ResponseCode::PENDING),
            1 => ::std::option::Option::Some(ResponseCode::SUCCESSFUL),
            2 => ::std::option::Option::Some(ResponseCode::ERROR),
            3 => ::std::option::Option::Some(ResponseCode::FINISHED),
            4 => ::std::option::Option::Some(ResponseCode::EXPIRED),
            5 => ::std::option::Option::Some(ResponseCode::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseCode] = &[
            ResponseCode::PENDING,
            ResponseCode::SUCCESSFUL,
            ResponseCode::ERROR,
            ResponseCode::FINISHED,
            ResponseCode::EXPIRED,
            ResponseCode::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResponseCode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResponseCode {
}

impl ::std::default::Default for ResponseCode {
    fn default() -> Self {
        ResponseCode::PENDING
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tRpc.proto\x12\x1aCatalyst.Protocol.Rpc.Node\x1a\nPeer.proto\x1a\x12C\
    ryptography.proto\x1a\x0cDeltas.proto\x1a\nWire.proto\x1a\x11Transaction\
    .proto\"&\n\x0eVersionRequest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\
    \x05query\"+\n\x0fVersionResponse\x12\x18\n\x07version\x18\x01\x20\x01(\
    \tR\x07version\"&\n\x0eGetInfoRequest\x12\x14\n\x05query\x18\x01\x20\x01\
    (\x08R\x05query\"'\n\x0fGetInfoResponse\x12\x14\n\x05query\x18\x01\x20\
    \x01(\tR\x05query\"+\n\x13CreateWalletRequest\x12\x14\n\x05query\x18\x01\
    \x20\x01(\x08R\x05query\",\n\x14CreateWalletResponse\x12\x14\n\x05query\
    \x18\x01\x20\x01(\tR\x05query\")\n\x11ListWalletRequest\x12\x14\n\x05que\
    ry\x18\x01\x20\x01(\x08R\x05query\"*\n\x12ListWalletResponse\x12\x14\n\
    \x05query\x18\x01\x20\x01(\tR\x05query\",\n\x14CreateAddressRequest\x12\
    \x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"-\n\x15CreateAddressResp\
    onse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\")\n\x11GetAddressR\
    equest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"*\n\x12GetAddr\
    essResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"*\n\x12List\
    AddressRequest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"+\n\
    \x13ListAddressResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\
    \".\n\x16ValidateAddressRequest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\
    \x05query\"/\n\x17ValidateAddressResponse\x12\x14\n\x05query\x18\x01\x20\
    \x01(\tR\x05query\")\n\x11GetBalanceRequest\x12\x14\n\x05query\x18\x01\
    \x20\x01(\x08R\x05query\"*\n\x12GetBalanceResponse\x12\x14\n\x05query\
    \x18\x01\x20\x01(\tR\x05query\"3\n\x1bCreateRawTransactionRequest\x12\
    \x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"4\n\x1cCreateRawTransact\
    ionResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"1\n\x19Sign\
    RawTransactionRequest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\
    \"2\n\x1aSignRawTransactionResponse\x12\x14\n\x05query\x18\x01\x20\x01(\
    \tR\x05query\"3\n\x1bDecodeRawTransactionRequest\x12\x14\n\x05query\x18\
    \x01\x20\x01(\x08R\x05query\"4\n\x1cDecodeRawTransactionResponse\x12\x14\
    \n\x05query\x18\x01\x20\x01(\tR\x05query\"p\n\x1eBroadcastRawTransaction\
    Request\x12N\n\x0btransaction\x18\x01\x20\x01(\x0b2,.Catalyst.Protocol.W\
    ire.TransactionBroadcastR\x0btransaction\"p\n\x1fBroadcastRawTransaction\
    Response\x12M\n\rresponse_code\x18\x01\x20\x01(\x0e2(.Catalyst.Protocol.\
    Rpc.Node.ResponseCodeR\x0cresponseCode\"%\n\rSendToRequest\x12\x14\n\x05\
    query\x18\x01\x20\x01(\x08R\x05query\"&\n\x0eSendToResponse\x12\x14\n\
    \x05query\x18\x01\x20\x01(\tR\x05query\")\n\x11SendToFromRequest\x12\x14\
    \n\x05query\x18\x01\x20\x01(\x08R\x05query\"*\n\x12SendToFromResponse\
    \x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"'\n\x0fSendManyRequest\
    \x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"(\n\x10SendManyRespo\
    nse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"+\n\x13SendFromMany\
    Request\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\",\n\x14SendFr\
    omManyResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"&\n\x0eA\
    ddNodeRequest\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"'\n\x0f\
    AddNodeResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"\x14\n\
    \x12GetPeerListRequest\"K\n\x13GetPeerListResponse\x124\n\x05peers\x18\
    \x01\x20\x03(\x0b2\x1e.Catalyst.Protocol.Peer.PeerIdR\x05peers\"I\n\x18G\
    etPeerReputationRequest\x12\x1d\n\npublic_key\x18\x01\x20\x01(\x0cR\tpub\
    licKey\x12\x0e\n\x02ip\x18\x02\x20\x01(\x0cR\x02ip\";\n\x19GetPeerReputa\
    tionResponse\x12\x1e\n\nreputation\x18\x01\x20\x01(\x05R\nreputation\"f\
    \n\x17SetPeerBlacklistRequest\x12\x1d\n\npublic_key\x18\x01\x20\x01(\x0c\
    R\tpublicKey\x12\x0e\n\x02ip\x18\x02\x20\x01(\x0cR\x02ip\x12\x1c\n\tblac\
    klist\x18\x03\x20\x01(\x08R\tblacklist\"g\n\x18SetPeerBlacklistResponse\
    \x12\x1d\n\npublic_key\x18\x01\x20\x01(\x0cR\tpublicKey\x12\x0e\n\x02ip\
    \x18\x02\x20\x01(\x0cR\x02ip\x12\x1c\n\tblacklist\x18\x03\x20\x01(\x08R\
    \tblacklist\"C\n\x12GetPeerInfoRequest\x12\x1d\n\npublic_key\x18\x01\x20\
    \x01(\x0cR\tpublicKey\x12\x0e\n\x02ip\x18\x02\x20\x01(\x0cR\x02ip\"T\n\
    \x13GetPeerInfoResponse\x12=\n\tpeer_info\x18\x01\x20\x03(\x0b2\x20.Cata\
    lyst.Protocol.Peer.PeerInfoR\x08peerInfo\"1\n\x19GetConnectionCountReque\
    st\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"2\n\x1aGetConnecti\
    onCountResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"7\n\x0f\
    GetDeltaRequest\x12$\n\x0edelta_dfs_hash\x18\x01\x20\x01(\x0cR\x0cdeltaD\
    fsHash\"I\n\x10GetDeltaResponse\x125\n\x05delta\x18\x01\x20\x01(\x0b2\
    \x1f.Catalyst.Protocol.Deltas.DeltaR\x05delta\")\n\x11GetMempoolRequest\
    \x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"d\n\x12GetMempoolRes\
    ponse\x12N\n\x0ctransactions\x18\x01\x20\x03(\x0b2*.Catalyst.Protocol.Tr\
    ansaction.PublicEntryR\x0ctransactions\"\x9e\x01\n\x12SignMessageRequest\
    \x12\x18\n\x07message\x18\x01\x20\x01(\x0cR\x07message\x12\x15\n\x06key_\
    id\x18\x02\x20\x01(\tR\x05keyId\x12W\n\x0fsigning_context\x18\x03\x20\
    \x01(\x0b2..Catalyst.Protocol.Cryptography.SigningContextR\x0esigningCon\
    text\"}\n\x13SignMessageResponse\x12\x1c\n\tsignature\x18\x01\x20\x01(\
    \x0cR\tsignature\x12\x1d\n\npublic_key\x18\x02\x20\x01(\x0cR\tpublicKey\
    \x12)\n\x10original_message\x18\x03\x20\x01(\x0cR\x0foriginalMessage\"\
    \xc6\x01\n\x14VerifyMessageRequest\x12\x1c\n\tsignature\x18\x01\x20\x01(\
    \x0cR\tsignature\x12\x1d\n\npublic_key\x18\x02\x20\x01(\x0cR\tpublicKey\
    \x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\x07message\x12W\n\x0fsigning\
    _context\x18\x04\x20\x01(\x0b2..Catalyst.Protocol.Cryptography.SigningCo\
    ntextR\x0esigningContext\"@\n\x15VerifyMessageResponse\x12'\n\x10is_sign\
    ed_by_key\x18\x01\x20\x01(\x08R\risSignedByKey\",\n\x14ServiceStatusRequ\
    est\x12\x14\n\x05query\x18\x01\x20\x01(\x08R\x05query\"-\n\x15ServiceSta\
    tusResponse\x12\x14\n\x05query\x18\x01\x20\x01(\tR\x05query\"c\n\x13AddF\
    ileToDfsRequest\x12\x1b\n\tfile_size\x18\x01\x20\x01(\x04R\x08fileSize\
    \x12\x1b\n\tfile_name\x18\x02\x20\x01(\tR\x08fileName\x12\x12\n\x04node\
    \x18\x03\x20\x01(\tR\x04node\"V\n\x14AddFileToDfsResponse\x12#\n\rrespon\
    se_code\x18\x01\x20\x01(\x0cR\x0cresponseCode\x12\x19\n\x08dfs_hash\x18\
    \x02\x20\x01(\tR\x07dfsHash\"\x8a\x01\n\x18TransferFileBytesRequest\x12\
    \x19\n\x08chunk_id\x18\x01\x20\x01(\rR\x07chunkId\x12\x1f\n\x0bchunk_byt\
    es\x18\x02\x20\x01(\x0cR\nchunkBytes\x122\n\x15correlation_file_name\x18\
    \x03\x20\x01(\x0cR\x13correlationFileName\"@\n\x19TransferFileBytesRespo\
    nse\x12#\n\rresponse_code\x18\x01\x20\x01(\x0cR\x0cresponseCode\"K\n\x11\
    RemovePeerRequest\x12\x17\n\x07peer_ip\x18\x01\x20\x01(\x0cR\x06peerIp\
    \x12\x1d\n\npublic_key\x18\x02\x20\x01(\x0cR\tpublicKey\"9\n\x12RemovePe\
    erResponse\x12#\n\rdeleted_count\x18\x01\x20\x01(\rR\x0cdeletedCount\"\
    \x15\n\x13GetPeerCountRequest\"5\n\x14GetPeerCountResponse\x12\x1d\n\npe\
    er_count\x18\x01\x20\x01(\x05R\tpeerCount\"2\n\x15GetFileFromDfsRequest\
    \x12\x19\n\x08dfs_hash\x18\x01\x20\x01(\tR\x07dfsHash\"Z\n\x16GetFileFro\
    mDfsResponse\x12\x1b\n\tfile_size\x18\x01\x20\x01(\x04R\x08fileSize\x12#\
    \n\rresponse_code\x18\x02\x20\x01(\x0cR\x0cresponseCode\";\n\x18SetPeerD\
    ataFolderRequest\x12\x1f\n\x0bdata_folder\x18\x01\x20\x01(\tR\ndataFolde\
    r\"1\n\x19SetPeerDataFolderResponse\x12\x14\n\x05query\x18\x01\x20\x01(\
    \x08R\x05query*]\n\x0cResponseCode\x12\x0b\n\x07PENDING\x10\0\x12\x0e\n\
    \nSUCCESSFUL\x10\x01\x12\t\n\x05ERROR\x10\x02\x12\x0c\n\x08FINISHED\x10\
    \x03\x12\x0b\n\x07EXPIRED\x10\x04\x12\n\n\x06FAILED\x10\x05B\x02P\x01J\
    \xf0I\n\x07\x12\x05\x13\0\xc6\x02\x01\n\xdf\x06\n\x01\x0c\x12\x03\x13\0\
    \x122\xd4\x06*\n\x20Copyright\x20(c)\x202019\x20Catalyst\x20Network\n\n\
    \x20This\x20file\x20is\x20part\x20of\x20Catalyst.Network.Protocol.Protob\
    uffs\x20<https://github.com/catalyst-network/protocol-protobuffs>\n\n\
    \x20Catalyst.Network.Protocol.Protobuffs\x20is\x20free\x20software:\x20y\
    ou\x20can\x20redistribute\x20it\x20and/or\x20modify\n\x20it\x20under\x20\
    the\x20terms\x20of\x20the\x20GNU\x20General\x20Public\x20License\x20as\
    \x20published\x20by\n\x20the\x20Free\x20Software\x20Foundation,\x20eithe\
    r\x20version\x202\x20of\x20the\x20License,\x20or\n\x20(at\x20your\x20opt\
    ion)\x20any\x20later\x20version.\n\x20\n\x20Catalyst.Network.Protocol.Pr\
    otobuffs\x20is\x20distributed\x20in\x20the\x20hope\x20that\x20it\x20will\
    \x20be\x20useful,\n\x20but\x20WITHOUT\x20ANY\x20WARRANTY;\x20without\x20\
    even\x20the\x20implied\x20warranty\x20of\n\x20MERCHANTABILITY\x20or\x20F\
    ITNESS\x20FOR\x20A\x20PARTICULAR\x20PURPOSE.\x20See\x20the\n\x20GNU\x20G\
    eneral\x20Public\x20License\x20for\x20more\x20details.\n\x20\n\x20You\
    \x20should\x20have\x20received\x20a\x20copy\x20of\x20the\x20GNU\x20Gener\
    al\x20Public\x20License\n\x20along\x20with\x20Catalyst.Network.Protocol.\
    Protobuffs\x20If\x20not,\x20see\x20<https://www.gnu.org/licenses/>.\n\n\
    \x08\n\x01\x08\x12\x03\x15\0\"\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x15\0\"\
    \n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x15\x07\x1a\n\r\n\x06\x08\xe7\x07\
    \0\x02\0\x12\x03\x15\x07\x1a\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\
    \x15\x07\x1a\n\x0c\n\x05\x08\xe7\x07\0\x03\x12\x03\x15\x1d!\n\x08\n\x01\
    \x02\x12\x03\x17\x08\"\n\t\n\x02\x03\0\x12\x03\x19\x07\x13\n\t\n\x02\x03\
    \x01\x12\x03\x1a\x07\x1b\n\t\n\x02\x03\x02\x12\x03\x1b\x07\x15\n\t\n\x02\
    \x03\x03\x12\x03\x1c\x07\x13\n\t\n\x02\x03\x04\x12\x03\x1d\x07\x1a\n\n\n\
    \x02\x05\0\x12\x04\x1f\0&\x01\n\n\n\x03\x05\0\x01\x12\x03\x1f\x05\x11\n\
    \x0b\n\x04\x05\0\x02\0\x12\x03\x20\x08\x14\n\x0c\n\x05\x05\0\x02\0\x01\
    \x12\x03\x20\x08\x0f\n\x0c\n\x05\x05\0\x02\0\x02\x12\x03\x20\x12\x13\n\
    \x0b\n\x04\x05\0\x02\x01\x12\x03!\x08\x17\n\x0c\n\x05\x05\0\x02\x01\x01\
    \x12\x03!\x08\x12\n\x0c\n\x05\x05\0\x02\x01\x02\x12\x03!\x15\x16\n\x0b\n\
    \x04\x05\0\x02\x02\x12\x03\"\x08\x12\n\x0c\n\x05\x05\0\x02\x02\x01\x12\
    \x03\"\x08\r\n\x0c\n\x05\x05\0\x02\x02\x02\x12\x03\"\x10\x11\n\x0b\n\x04\
    \x05\0\x02\x03\x12\x03#\x08\x15\n\x0c\n\x05\x05\0\x02\x03\x01\x12\x03#\
    \x08\x10\n\x0c\n\x05\x05\0\x02\x03\x02\x12\x03#\x13\x14\n\x0b\n\x04\x05\
    \0\x02\x04\x12\x03$\x08\x14\n\x0c\n\x05\x05\0\x02\x04\x01\x12\x03$\x08\
    \x0f\n\x0c\n\x05\x05\0\x02\x04\x02\x12\x03$\x12\x13\n\x0b\n\x04\x05\0\
    \x02\x05\x12\x03%\x08\x13\n\x0c\n\x05\x05\0\x02\x05\x01\x12\x03%\x08\x0e\
    \n\x0c\n\x05\x05\0\x02\x05\x02\x12\x03%\x11\x12\n\n\n\x02\x04\0\x12\x04(\
    \0*\x01\n\n\n\x03\x04\0\x01\x12\x03(\x08\x16\n\x0b\n\x04\x04\0\x02\0\x12\
    \x03)\x04\x13\n\r\n\x05\x04\0\x02\0\x04\x12\x04)\x04(\x18\n\x0c\n\x05\
    \x04\0\x02\0\x05\x12\x03)\x04\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03)\t\
    \x0e\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03)\x11\x12\n\n\n\x02\x04\x01\x12\
    \x04,\0.\x01\n\n\n\x03\x04\x01\x01\x12\x03,\x08\x17\n\x0b\n\x04\x04\x01\
    \x02\0\x12\x03-\x04\x17\n\r\n\x05\x04\x01\x02\0\x04\x12\x04-\x04,\x19\n\
    \x0c\n\x05\x04\x01\x02\0\x05\x12\x03-\x04\n\n\x0c\n\x05\x04\x01\x02\0\
    \x01\x12\x03-\x0b\x12\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03-\x15\x16\n\n\
    \n\x02\x04\x02\x12\x040\02\x01\n\n\n\x03\x04\x02\x01\x12\x030\x08\x16\n\
    \x0b\n\x04\x04\x02\x02\0\x12\x031\x04\x13\n\r\n\x05\x04\x02\x02\0\x04\
    \x12\x041\x040\x18\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x031\x04\x08\n\x0c\
    \n\x05\x04\x02\x02\0\x01\x12\x031\t\x0e\n\x0c\n\x05\x04\x02\x02\0\x03\
    \x12\x031\x11\x12\n\n\n\x02\x04\x03\x12\x044\06\x01\n\n\n\x03\x04\x03\
    \x01\x12\x034\x08\x17\n\x0b\n\x04\x04\x03\x02\0\x12\x035\x04\x15\n\r\n\
    \x05\x04\x03\x02\0\x04\x12\x045\x044\x19\n\x0c\n\x05\x04\x03\x02\0\x05\
    \x12\x035\x04\n\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x035\x0b\x10\n\x0c\n\
    \x05\x04\x03\x02\0\x03\x12\x035\x13\x14\n\n\n\x02\x04\x04\x12\x048\0:\
    \x01\n\n\n\x03\x04\x04\x01\x12\x038\x08\x1b\n\x0b\n\x04\x04\x04\x02\0\
    \x12\x039\x04\x13\n\r\n\x05\x04\x04\x02\0\x04\x12\x049\x048\x1d\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x039\x04\x08\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x039\t\x0e\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x039\x11\x12\n\n\n\x02\
    \x04\x05\x12\x04<\0>\x01\n\n\n\x03\x04\x05\x01\x12\x03<\x08\x1c\n\x0b\n\
    \x04\x04\x05\x02\0\x12\x03=\x04\x15\n\r\n\x05\x04\x05\x02\0\x04\x12\x04=\
    \x04<\x1e\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03=\x04\n\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03=\x0b\x10\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03=\
    \x13\x14\n\n\n\x02\x04\x06\x12\x04@\0B\x01\n\n\n\x03\x04\x06\x01\x12\x03\
    @\x08\x19\n\x0b\n\x04\x04\x06\x02\0\x12\x03A\x04\x13\n\r\n\x05\x04\x06\
    \x02\0\x04\x12\x04A\x04@\x1b\n\x0c\n\x05\x04\x06\x02\0\x05\x12\x03A\x04\
    \x08\n\x0c\n\x05\x04\x06\x02\0\x01\x12\x03A\t\x0e\n\x0c\n\x05\x04\x06\
    \x02\0\x03\x12\x03A\x11\x12\n\n\n\x02\x04\x07\x12\x04D\0F\x01\n\n\n\x03\
    \x04\x07\x01\x12\x03D\x08\x1a\n\x0b\n\x04\x04\x07\x02\0\x12\x03E\x04\x15\
    \n\r\n\x05\x04\x07\x02\0\x04\x12\x04E\x04D\x1c\n\x0c\n\x05\x04\x07\x02\0\
    \x05\x12\x03E\x04\n\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03E\x0b\x10\n\x0c\
    \n\x05\x04\x07\x02\0\x03\x12\x03E\x13\x14\n\n\n\x02\x04\x08\x12\x04H\0J\
    \x01\n\n\n\x03\x04\x08\x01\x12\x03H\x08\x1c\n\x0b\n\x04\x04\x08\x02\0\
    \x12\x03I\x04\x13\n\r\n\x05\x04\x08\x02\0\x04\x12\x04I\x04H\x1e\n\x0c\n\
    \x05\x04\x08\x02\0\x05\x12\x03I\x04\x08\n\x0c\n\x05\x04\x08\x02\0\x01\
    \x12\x03I\t\x0e\n\x0c\n\x05\x04\x08\x02\0\x03\x12\x03I\x11\x12\n\n\n\x02\
    \x04\t\x12\x04L\0N\x01\n\n\n\x03\x04\t\x01\x12\x03L\x08\x1d\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03M\x04\x15\n\r\n\x05\x04\t\x02\0\x04\x12\x04M\x04L\
    \x1f\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03M\x04\n\n\x0c\n\x05\x04\t\x02\0\
    \x01\x12\x03M\x0b\x10\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03M\x13\x14\n\n\n\
    \x02\x04\n\x12\x04P\0R\x01\n\n\n\x03\x04\n\x01\x12\x03P\x08\x19\n\x0b\n\
    \x04\x04\n\x02\0\x12\x03Q\x04\x13\n\r\n\x05\x04\n\x02\0\x04\x12\x04Q\x04\
    P\x1b\n\x0c\n\x05\x04\n\x02\0\x05\x12\x03Q\x04\x08\n\x0c\n\x05\x04\n\x02\
    \0\x01\x12\x03Q\t\x0e\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03Q\x11\x12\n\n\n\
    \x02\x04\x0b\x12\x04T\0V\x01\n\n\n\x03\x04\x0b\x01\x12\x03T\x08\x1a\n\
    \x0b\n\x04\x04\x0b\x02\0\x12\x03U\x04\x15\n\r\n\x05\x04\x0b\x02\0\x04\
    \x12\x04U\x04T\x1c\n\x0c\n\x05\x04\x0b\x02\0\x05\x12\x03U\x04\n\n\x0c\n\
    \x05\x04\x0b\x02\0\x01\x12\x03U\x0b\x10\n\x0c\n\x05\x04\x0b\x02\0\x03\
    \x12\x03U\x13\x14\n\n\n\x02\x04\x0c\x12\x04X\0Z\x01\n\n\n\x03\x04\x0c\
    \x01\x12\x03X\x08\x1a\n\x0b\n\x04\x04\x0c\x02\0\x12\x03Y\x04\x13\n\r\n\
    \x05\x04\x0c\x02\0\x04\x12\x04Y\x04X\x1c\n\x0c\n\x05\x04\x0c\x02\0\x05\
    \x12\x03Y\x04\x08\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03Y\t\x0e\n\x0c\n\
    \x05\x04\x0c\x02\0\x03\x12\x03Y\x11\x12\n\n\n\x02\x04\r\x12\x04\\\0^\x01\
    \n\n\n\x03\x04\r\x01\x12\x03\\\x08\x1b\n\x0b\n\x04\x04\r\x02\0\x12\x03]\
    \x04\x15\n\r\n\x05\x04\r\x02\0\x04\x12\x04]\x04\\\x1d\n\x0c\n\x05\x04\r\
    \x02\0\x05\x12\x03]\x04\n\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03]\x0b\x10\n\
    \x0c\n\x05\x04\r\x02\0\x03\x12\x03]\x13\x14\n\n\n\x02\x04\x0e\x12\x04`\0\
    b\x01\n\n\n\x03\x04\x0e\x01\x12\x03`\x08\x1e\n\x0b\n\x04\x04\x0e\x02\0\
    \x12\x03a\x04\x13\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04a\x04`\x20\n\x0c\n\
    \x05\x04\x0e\x02\0\x05\x12\x03a\x04\x08\n\x0c\n\x05\x04\x0e\x02\0\x01\
    \x12\x03a\t\x0e\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03a\x11\x12\n\n\n\x02\
    \x04\x0f\x12\x04d\0f\x01\n\n\n\x03\x04\x0f\x01\x12\x03d\x08\x1f\n\x0b\n\
    \x04\x04\x0f\x02\0\x12\x03e\x04\x15\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04e\
    \x04d!\n\x0c\n\x05\x04\x0f\x02\0\x05\x12\x03e\x04\n\n\x0c\n\x05\x04\x0f\
    \x02\0\x01\x12\x03e\x0b\x10\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03e\x13\
    \x14\n\n\n\x02\x04\x10\x12\x04h\0j\x01\n\n\n\x03\x04\x10\x01\x12\x03h\
    \x08\x19\n\x0b\n\x04\x04\x10\x02\0\x12\x03i\x04\x13\n\r\n\x05\x04\x10\
    \x02\0\x04\x12\x04i\x04h\x1b\n\x0c\n\x05\x04\x10\x02\0\x05\x12\x03i\x04\
    \x08\n\x0c\n\x05\x04\x10\x02\0\x01\x12\x03i\t\x0e\n\x0c\n\x05\x04\x10\
    \x02\0\x03\x12\x03i\x11\x12\n\n\n\x02\x04\x11\x12\x04l\0n\x01\n\n\n\x03\
    \x04\x11\x01\x12\x03l\x08\x1a\n\x0b\n\x04\x04\x11\x02\0\x12\x03m\x04\x15\
    \n\r\n\x05\x04\x11\x02\0\x04\x12\x04m\x04l\x1c\n\x0c\n\x05\x04\x11\x02\0\
    \x05\x12\x03m\x04\n\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03m\x0b\x10\n\x0c\
    \n\x05\x04\x11\x02\0\x03\x12\x03m\x13\x14\n\n\n\x02\x04\x12\x12\x04p\0r\
    \x01\n\n\n\x03\x04\x12\x01\x12\x03p\x08#\n\x0b\n\x04\x04\x12\x02\0\x12\
    \x03q\x04\x13\n\r\n\x05\x04\x12\x02\0\x04\x12\x04q\x04p%\n\x0c\n\x05\x04\
    \x12\x02\0\x05\x12\x03q\x04\x08\n\x0c\n\x05\x04\x12\x02\0\x01\x12\x03q\t\
    \x0e\n\x0c\n\x05\x04\x12\x02\0\x03\x12\x03q\x11\x12\n\n\n\x02\x04\x13\
    \x12\x04t\0v\x01\n\n\n\x03\x04\x13\x01\x12\x03t\x08$\n\x0b\n\x04\x04\x13\
    \x02\0\x12\x03u\x04\x15\n\r\n\x05\x04\x13\x02\0\x04\x12\x04u\x04t&\n\x0c\
    \n\x05\x04\x13\x02\0\x05\x12\x03u\x04\n\n\x0c\n\x05\x04\x13\x02\0\x01\
    \x12\x03u\x0b\x10\n\x0c\n\x05\x04\x13\x02\0\x03\x12\x03u\x13\x14\n\n\n\
    \x02\x04\x14\x12\x04x\0z\x01\n\n\n\x03\x04\x14\x01\x12\x03x\x08!\n\x0b\n\
    \x04\x04\x14\x02\0\x12\x03y\x04\x13\n\r\n\x05\x04\x14\x02\0\x04\x12\x04y\
    \x04x#\n\x0c\n\x05\x04\x14\x02\0\x05\x12\x03y\x04\x08\n\x0c\n\x05\x04\
    \x14\x02\0\x01\x12\x03y\t\x0e\n\x0c\n\x05\x04\x14\x02\0\x03\x12\x03y\x11\
    \x12\n\n\n\x02\x04\x15\x12\x04|\0~\x01\n\n\n\x03\x04\x15\x01\x12\x03|\
    \x08\"\n\x0b\n\x04\x04\x15\x02\0\x12\x03}\x04\x15\n\r\n\x05\x04\x15\x02\
    \0\x04\x12\x04}\x04|$\n\x0c\n\x05\x04\x15\x02\0\x05\x12\x03}\x04\n\n\x0c\
    \n\x05\x04\x15\x02\0\x01\x12\x03}\x0b\x10\n\x0c\n\x05\x04\x15\x02\0\x03\
    \x12\x03}\x13\x14\n\x0c\n\x02\x04\x16\x12\x06\x80\x01\0\x82\x01\x01\n\
    \x0b\n\x03\x04\x16\x01\x12\x04\x80\x01\x08#\n\x0c\n\x04\x04\x16\x02\0\
    \x12\x04\x81\x01\x04\x13\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\x81\x01\
    \x04\x80\x01%\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x81\x01\x04\x08\n\r\n\
    \x05\x04\x16\x02\0\x01\x12\x04\x81\x01\t\x0e\n\r\n\x05\x04\x16\x02\0\x03\
    \x12\x04\x81\x01\x11\x12\n\x0c\n\x02\x04\x17\x12\x06\x84\x01\0\x86\x01\
    \x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x84\x01\x08$\n\x0c\n\x04\x04\x17\
    \x02\0\x12\x04\x85\x01\x04\x15\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\x85\
    \x01\x04\x84\x01&\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x85\x01\x04\n\n\r\
    \n\x05\x04\x17\x02\0\x01\x12\x04\x85\x01\x0b\x10\n\r\n\x05\x04\x17\x02\0\
    \x03\x12\x04\x85\x01\x13\x14\n\x0c\n\x02\x04\x18\x12\x06\x88\x01\0\x8a\
    \x01\x01\n\x0b\n\x03\x04\x18\x01\x12\x04\x88\x01\x08&\n\x0c\n\x04\x04\
    \x18\x02\0\x12\x04\x89\x01\x082\n\x0f\n\x05\x04\x18\x02\0\x04\x12\x06\
    \x89\x01\x08\x88\x01(\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\x89\x01\x08!\n\
    \r\n\x05\x04\x18\x02\0\x01\x12\x04\x89\x01\"-\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\x89\x0101\n\x0c\n\x02\x04\x19\x12\x06\x8c\x01\0\x8e\x01\x01\
    \n\x0b\n\x03\x04\x19\x01\x12\x04\x8c\x01\x08'\n\x0c\n\x04\x04\x19\x02\0\
    \x12\x04\x8d\x01\x04#\n\x0f\n\x05\x04\x19\x02\0\x04\x12\x06\x8d\x01\x04\
    \x8c\x01)\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\x8d\x01\x04\x10\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\x8d\x01\x11\x1e\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\x8d\x01!\"\n\x0c\n\x02\x04\x1a\x12\x06\x90\x01\0\x92\x01\x01\n\
    \x0b\n\x03\x04\x1a\x01\x12\x04\x90\x01\x08\x15\n\x0c\n\x04\x04\x1a\x02\0\
    \x12\x04\x91\x01\x04\x13\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\x91\x01\
    \x04\x90\x01\x17\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\x91\x01\x04\x08\n\r\
    \n\x05\x04\x1a\x02\0\x01\x12\x04\x91\x01\t\x0e\n\r\n\x05\x04\x1a\x02\0\
    \x03\x12\x04\x91\x01\x11\x12\n\x0c\n\x02\x04\x1b\x12\x06\x94\x01\0\x96\
    \x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\x04\x94\x01\x08\x16\n\x0c\n\x04\x04\
    \x1b\x02\0\x12\x04\x95\x01\x04\x15\n\x0f\n\x05\x04\x1b\x02\0\x04\x12\x06\
    \x95\x01\x04\x94\x01\x18\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\x95\x01\x04\
    \n\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x95\x01\x0b\x10\n\r\n\x05\x04\x1b\
    \x02\0\x03\x12\x04\x95\x01\x13\x14\n\x0c\n\x02\x04\x1c\x12\x06\x98\x01\0\
    \x9a\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x98\x01\x08\x19\n\x0c\n\x04\
    \x04\x1c\x02\0\x12\x04\x99\x01\x04\x13\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\
    \x06\x99\x01\x04\x98\x01\x1b\n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\x99\x01\
    \x04\x08\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\x99\x01\t\x0e\n\r\n\x05\x04\
    \x1c\x02\0\x03\x12\x04\x99\x01\x11\x12\n\x0c\n\x02\x04\x1d\x12\x06\x9c\
    \x01\0\x9e\x01\x01\n\x0b\n\x03\x04\x1d\x01\x12\x04\x9c\x01\x08\x1a\n\x0c\
    \n\x04\x04\x1d\x02\0\x12\x04\x9d\x01\x04\x15\n\x0f\n\x05\x04\x1d\x02\0\
    \x04\x12\x06\x9d\x01\x04\x9c\x01\x1c\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\
    \x9d\x01\x04\n\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\x9d\x01\x0b\x10\n\r\n\
    \x05\x04\x1d\x02\0\x03\x12\x04\x9d\x01\x13\x14\n\x0c\n\x02\x04\x1e\x12\
    \x06\xa0\x01\0\xa2\x01\x01\n\x0b\n\x03\x04\x1e\x01\x12\x04\xa0\x01\x08\
    \x17\n\x0c\n\x04\x04\x1e\x02\0\x12\x04\xa1\x01\x04\x13\n\x0f\n\x05\x04\
    \x1e\x02\0\x04\x12\x06\xa1\x01\x04\xa0\x01\x19\n\r\n\x05\x04\x1e\x02\0\
    \x05\x12\x04\xa1\x01\x04\x08\n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xa1\x01\
    \t\x0e\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xa1\x01\x11\x12\n\x0c\n\x02\
    \x04\x1f\x12\x06\xa4\x01\0\xa6\x01\x01\n\x0b\n\x03\x04\x1f\x01\x12\x04\
    \xa4\x01\x08\x18\n\x0c\n\x04\x04\x1f\x02\0\x12\x04\xa5\x01\x04\x15\n\x0f\
    \n\x05\x04\x1f\x02\0\x04\x12\x06\xa5\x01\x04\xa4\x01\x1a\n\r\n\x05\x04\
    \x1f\x02\0\x05\x12\x04\xa5\x01\x04\n\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\
    \xa5\x01\x0b\x10\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xa5\x01\x13\x14\n\
    \x0c\n\x02\x04\x20\x12\x06\xa8\x01\0\xaa\x01\x01\n\x0b\n\x03\x04\x20\x01\
    \x12\x04\xa8\x01\x08\x1b\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xa9\x01\x04\
    \x13\n\x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xa9\x01\x04\xa8\x01\x1d\n\r\n\
    \x05\x04\x20\x02\0\x05\x12\x04\xa9\x01\x04\x08\n\r\n\x05\x04\x20\x02\0\
    \x01\x12\x04\xa9\x01\t\x0e\n\r\n\x05\x04\x20\x02\0\x03\x12\x04\xa9\x01\
    \x11\x12\n\x0c\n\x02\x04!\x12\x06\xac\x01\0\xae\x01\x01\n\x0b\n\x03\x04!\
    \x01\x12\x04\xac\x01\x08\x1c\n\x0c\n\x04\x04!\x02\0\x12\x04\xad\x01\x04\
    \x15\n\x0f\n\x05\x04!\x02\0\x04\x12\x06\xad\x01\x04\xac\x01\x1e\n\r\n\
    \x05\x04!\x02\0\x05\x12\x04\xad\x01\x04\n\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\xad\x01\x0b\x10\n\r\n\x05\x04!\x02\0\x03\x12\x04\xad\x01\x13\x14\n\
    \x0c\n\x02\x04\"\x12\x06\xb0\x01\0\xb2\x01\x01\n\x0b\n\x03\x04\"\x01\x12\
    \x04\xb0\x01\x08\x16\n\x0c\n\x04\x04\"\x02\0\x12\x04\xb1\x01\x04\x13\n\
    \x0f\n\x05\x04\"\x02\0\x04\x12\x06\xb1\x01\x04\xb0\x01\x18\n\r\n\x05\x04\
    \"\x02\0\x05\x12\x04\xb1\x01\x04\x08\n\r\n\x05\x04\"\x02\0\x01\x12\x04\
    \xb1\x01\t\x0e\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xb1\x01\x11\x12\n\x0c\n\
    \x02\x04#\x12\x06\xb4\x01\0\xb6\x01\x01\n\x0b\n\x03\x04#\x01\x12\x04\xb4\
    \x01\x08\x17\n\x0c\n\x04\x04#\x02\0\x12\x04\xb5\x01\x04\x15\n\x0f\n\x05\
    \x04#\x02\0\x04\x12\x06\xb5\x01\x04\xb4\x01\x19\n\r\n\x05\x04#\x02\0\x05\
    \x12\x04\xb5\x01\x04\n\n\r\n\x05\x04#\x02\0\x01\x12\x04\xb5\x01\x0b\x10\
    \n\r\n\x05\x04#\x02\0\x03\x12\x04\xb5\x01\x13\x14\n\n\n\x02\x04$\x12\x04\
    \xb8\x01\0\x1e\n\x0b\n\x03\x04$\x01\x12\x04\xb8\x01\x08\x1a\n\x0c\n\x02\
    \x04%\x12\x06\xba\x01\0\xbc\x01\x01\n\x0b\n\x03\x04%\x01\x12\x04\xba\x01\
    \x08\x1b\n\x0c\n\x04\x04%\x02\0\x12\x04\xbb\x01\x04#\n\r\n\x05\x04%\x02\
    \0\x04\x12\x04\xbb\x01\x04\x0c\n\r\n\x05\x04%\x02\0\x06\x12\x04\xbb\x01\
    \r\x18\n\r\n\x05\x04%\x02\0\x01\x12\x04\xbb\x01\x19\x1e\n\r\n\x05\x04%\
    \x02\0\x03\x12\x04\xbb\x01!\"\n\x0c\n\x02\x04&\x12\x06\xbe\x01\0\xc1\x01\
    \x01\n\x0b\n\x03\x04&\x01\x12\x04\xbe\x01\x08\x20\n\x0c\n\x04\x04&\x02\0\
    \x12\x04\xbf\x01\x04\x19\n\x0f\n\x05\x04&\x02\0\x04\x12\x06\xbf\x01\x04\
    \xbe\x01\"\n\r\n\x05\x04&\x02\0\x05\x12\x04\xbf\x01\x04\t\n\r\n\x05\x04&\
    \x02\0\x01\x12\x04\xbf\x01\n\x14\n\r\n\x05\x04&\x02\0\x03\x12\x04\xbf\
    \x01\x17\x18\n\x0c\n\x04\x04&\x02\x01\x12\x04\xc0\x01\x04\x11\n\x0f\n\
    \x05\x04&\x02\x01\x04\x12\x06\xc0\x01\x04\xbf\x01\x19\n\r\n\x05\x04&\x02\
    \x01\x05\x12\x04\xc0\x01\x04\t\n\r\n\x05\x04&\x02\x01\x01\x12\x04\xc0\
    \x01\n\x0c\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xc0\x01\x0f\x10\n\x0c\n\
    \x02\x04'\x12\x06\xc3\x01\0\xc5\x01\x01\n\x0b\n\x03\x04'\x01\x12\x04\xc3\
    \x01\x08!\n\x0c\n\x04\x04'\x02\0\x12\x04\xc4\x01\x03\x18\n\x0f\n\x05\x04\
    '\x02\0\x04\x12\x06\xc4\x01\x03\xc3\x01#\n\r\n\x05\x04'\x02\0\x05\x12\
    \x04\xc4\x01\x03\x08\n\r\n\x05\x04'\x02\0\x01\x12\x04\xc4\x01\t\x13\n\r\
    \n\x05\x04'\x02\0\x03\x12\x04\xc4\x01\x16\x17\n\x0c\n\x02\x04(\x12\x06\
    \xc7\x01\0\xcb\x01\x01\n\x0b\n\x03\x04(\x01\x12\x04\xc7\x01\x08\x1f\n\
    \x0c\n\x04\x04(\x02\0\x12\x04\xc8\x01\x04\x19\n\x0f\n\x05\x04(\x02\0\x04\
    \x12\x06\xc8\x01\x04\xc7\x01!\n\r\n\x05\x04(\x02\0\x05\x12\x04\xc8\x01\
    \x04\t\n\r\n\x05\x04(\x02\0\x01\x12\x04\xc8\x01\n\x14\n\r\n\x05\x04(\x02\
    \0\x03\x12\x04\xc8\x01\x17\x18\n\x0c\n\x04\x04(\x02\x01\x12\x04\xc9\x01\
    \x04\x11\n\x0f\n\x05\x04(\x02\x01\x04\x12\x06\xc9\x01\x04\xc8\x01\x19\n\
    \r\n\x05\x04(\x02\x01\x05\x12\x04\xc9\x01\x04\t\n\r\n\x05\x04(\x02\x01\
    \x01\x12\x04\xc9\x01\n\x0c\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xc9\x01\
    \x0f\x10\n\x0c\n\x04\x04(\x02\x02\x12\x04\xca\x01\x04\x17\n\x0f\n\x05\
    \x04(\x02\x02\x04\x12\x06\xca\x01\x04\xc9\x01\x11\n\r\n\x05\x04(\x02\x02\
    \x05\x12\x04\xca\x01\x04\x08\n\r\n\x05\x04(\x02\x02\x01\x12\x04\xca\x01\
    \t\x12\n\r\n\x05\x04(\x02\x02\x03\x12\x04\xca\x01\x15\x16\n\x0c\n\x02\
    \x04)\x12\x06\xcd\x01\0\xd1\x01\x01\n\x0b\n\x03\x04)\x01\x12\x04\xcd\x01\
    \x08\x20\n\x0c\n\x04\x04)\x02\0\x12\x04\xce\x01\x04\x19\n\x0f\n\x05\x04)\
    \x02\0\x04\x12\x06\xce\x01\x04\xcd\x01!\n\r\n\x05\x04)\x02\0\x05\x12\x04\
    \xce\x01\x04\t\n\r\n\x05\x04)\x02\0\x01\x12\x04\xce\x01\n\x14\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\xce\x01\x17\x18\n\x0c\n\x04\x04)\x02\x01\x12\x04\
    \xcf\x01\x04\x11\n\x0f\n\x05\x04)\x02\x01\x04\x12\x06\xcf\x01\x04\xce\
    \x01\x19\n\r\n\x05\x04)\x02\x01\x05\x12\x04\xcf\x01\x04\t\n\r\n\x05\x04)\
    \x02\x01\x01\x12\x04\xcf\x01\n\x0c\n\r\n\x05\x04)\x02\x01\x03\x12\x04\
    \xcf\x01\x0f\x10\n\x0c\n\x04\x04)\x02\x02\x12\x04\xd0\x01\x04\x17\n\x0f\
    \n\x05\x04)\x02\x02\x04\x12\x06\xd0\x01\x04\xcf\x01\x11\n\r\n\x05\x04)\
    \x02\x02\x05\x12\x04\xd0\x01\x04\x08\n\r\n\x05\x04)\x02\x02\x01\x12\x04\
    \xd0\x01\t\x12\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xd0\x01\x15\x16\n\x0c\
    \n\x02\x04*\x12\x06\xd3\x01\0\xd6\x01\x01\n\x0b\n\x03\x04*\x01\x12\x04\
    \xd3\x01\x08\x1a\n\x0c\n\x04\x04*\x02\0\x12\x04\xd4\x01\x04\x19\n\x0f\n\
    \x05\x04*\x02\0\x04\x12\x06\xd4\x01\x04\xd3\x01\x1c\n\r\n\x05\x04*\x02\0\
    \x05\x12\x04\xd4\x01\x04\t\n\r\n\x05\x04*\x02\0\x01\x12\x04\xd4\x01\n\
    \x14\n\r\n\x05\x04*\x02\0\x03\x12\x04\xd4\x01\x17\x18\n\x0c\n\x04\x04*\
    \x02\x01\x12\x04\xd5\x01\x04\x11\n\x0f\n\x05\x04*\x02\x01\x04\x12\x06\
    \xd5\x01\x04\xd4\x01\x19\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xd5\x01\x04\
    \t\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xd5\x01\n\x0c\n\r\n\x05\x04*\x02\
    \x01\x03\x12\x04\xd5\x01\x0f\x10\n\x0c\n\x02\x04+\x12\x06\xd8\x01\0\xda\
    \x01\x01\n\x0b\n\x03\x04+\x01\x12\x04\xd8\x01\x08\x1b\n\x0c\n\x04\x04+\
    \x02\0\x12\x04\xd9\x01\x04)\n\r\n\x05\x04+\x02\0\x04\x12\x04\xd9\x01\x04\
    \x0c\n\r\n\x05\x04+\x02\0\x06\x12\x04\xd9\x01\r\x1a\n\r\n\x05\x04+\x02\0\
    \x01\x12\x04\xd9\x01\x1b$\n\r\n\x05\x04+\x02\0\x03\x12\x04\xd9\x01'(\n\
    \x0c\n\x02\x04,\x12\x06\xdc\x01\0\xde\x01\x01\n\x0b\n\x03\x04,\x01\x12\
    \x04\xdc\x01\x08!\n\x0c\n\x04\x04,\x02\0\x12\x04\xdd\x01\x04\x13\n\x0f\n\
    \x05\x04,\x02\0\x04\x12\x06\xdd\x01\x04\xdc\x01#\n\r\n\x05\x04,\x02\0\
    \x05\x12\x04\xdd\x01\x04\x08\n\r\n\x05\x04,\x02\0\x01\x12\x04\xdd\x01\t\
    \x0e\n\r\n\x05\x04,\x02\0\x03\x12\x04\xdd\x01\x11\x12\n\x0c\n\x02\x04-\
    \x12\x06\xe0\x01\0\xe2\x01\x01\n\x0b\n\x03\x04-\x01\x12\x04\xe0\x01\x08\
    \"\n\x0c\n\x04\x04-\x02\0\x12\x04\xe1\x01\x04\x15\n\x0f\n\x05\x04-\x02\0\
    \x04\x12\x06\xe1\x01\x04\xe0\x01$\n\r\n\x05\x04-\x02\0\x05\x12\x04\xe1\
    \x01\x04\n\n\r\n\x05\x04-\x02\0\x01\x12\x04\xe1\x01\x0b\x10\n\r\n\x05\
    \x04-\x02\0\x03\x12\x04\xe1\x01\x13\x14\n\x0c\n\x02\x04.\x12\x06\xe4\x01\
    \0\xe6\x01\x01\n\x0b\n\x03\x04.\x01\x12\x04\xe4\x01\x08\x17\n\x0c\n\x04\
    \x04.\x02\0\x12\x04\xe5\x01\x04\x1d\n\x0f\n\x05\x04.\x02\0\x04\x12\x06\
    \xe5\x01\x04\xe4\x01\x19\n\r\n\x05\x04.\x02\0\x05\x12\x04\xe5\x01\x04\t\
    \n\r\n\x05\x04.\x02\0\x01\x12\x04\xe5\x01\n\x18\n\r\n\x05\x04.\x02\0\x03\
    \x12\x04\xe5\x01\x1b\x1c\n\x0c\n\x02\x04/\x12\x06\xe8\x01\0\xea\x01\x01\
    \n\x0b\n\x03\x04/\x01\x12\x04\xe8\x01\x08\x18\n\x0c\n\x04\x04/\x02\0\x12\
    \x04\xe9\x01\x04\x1b\n\x0f\n\x05\x04/\x02\0\x04\x12\x06\xe9\x01\x04\xe8\
    \x01\x1a\n\r\n\x05\x04/\x02\0\x06\x12\x04\xe9\x01\x04\x10\n\r\n\x05\x04/\
    \x02\0\x01\x12\x04\xe9\x01\x11\x16\n\r\n\x05\x04/\x02\0\x03\x12\x04\xe9\
    \x01\x19\x1a\n\x0c\n\x02\x040\x12\x06\xec\x01\0\xee\x01\x01\n\x0b\n\x03\
    \x040\x01\x12\x04\xec\x01\x08\x19\n\x0c\n\x04\x040\x02\0\x12\x04\xed\x01\
    \x04\x13\n\x0f\n\x05\x040\x02\0\x04\x12\x06\xed\x01\x04\xec\x01\x1b\n\r\
    \n\x05\x040\x02\0\x05\x12\x04\xed\x01\x04\x08\n\r\n\x05\x040\x02\0\x01\
    \x12\x04\xed\x01\t\x0e\n\r\n\x05\x040\x02\0\x03\x12\x04\xed\x01\x11\x12\
    \n\x0c\n\x02\x041\x12\x06\xf0\x01\0\xf2\x01\x01\n\x0b\n\x03\x041\x01\x12\
    \x04\xf0\x01\x08\x1a\n\x0c\n\x04\x041\x02\0\x12\x04\xf1\x01\x046\n\r\n\
    \x05\x041\x02\0\x04\x12\x04\xf1\x01\x04\x0c\n\r\n\x05\x041\x02\0\x06\x12\
    \x04\xf1\x01\r$\n\r\n\x05\x041\x02\0\x01\x12\x04\xf1\x01%1\n\r\n\x05\x04\
    1\x02\0\x03\x12\x04\xf1\x0145\n\x0c\n\x02\x042\x12\x06\xf4\x01\0\xf8\x01\
    \x01\n\x0b\n\x03\x042\x01\x12\x04\xf4\x01\x08\x1a\n\x0c\n\x04\x042\x02\0\
    \x12\x04\xf5\x01\x04\x16\n\x0f\n\x05\x042\x02\0\x04\x12\x06\xf5\x01\x04\
    \xf4\x01\x1c\n\r\n\x05\x042\x02\0\x05\x12\x04\xf5\x01\x04\t\n\r\n\x05\
    \x042\x02\0\x01\x12\x04\xf5\x01\n\x11\n\r\n\x05\x042\x02\0\x03\x12\x04\
    \xf5\x01\x14\x15\n\x0c\n\x04\x042\x02\x01\x12\x04\xf6\x01\x04\x16\n\x0f\
    \n\x05\x042\x02\x01\x04\x12\x06\xf6\x01\x04\xf5\x01\x16\n\r\n\x05\x042\
    \x02\x01\x05\x12\x04\xf6\x01\x04\n\n\r\n\x05\x042\x02\x01\x01\x12\x04\
    \xf6\x01\x0b\x11\n\r\n\x05\x042\x02\x01\x03\x12\x04\xf6\x01\x14\x15\n\
    \x0c\n\x04\x042\x02\x02\x12\x04\xf7\x01\x044\n\x0f\n\x05\x042\x02\x02\
    \x04\x12\x06\xf7\x01\x04\xf6\x01\x16\n\r\n\x05\x042\x02\x02\x06\x12\x04\
    \xf7\x01\x04\x1f\n\r\n\x05\x042\x02\x02\x01\x12\x04\xf7\x01\x20/\n\r\n\
    \x05\x042\x02\x02\x03\x12\x04\xf7\x0123\n\x0c\n\x02\x043\x12\x06\xfa\x01\
    \0\xfe\x01\x01\n\x0b\n\x03\x043\x01\x12\x04\xfa\x01\x08\x1b\n\x0c\n\x04\
    \x043\x02\0\x12\x04\xfb\x01\x04\x18\n\x0f\n\x05\x043\x02\0\x04\x12\x06\
    \xfb\x01\x04\xfa\x01\x1d\n\r\n\x05\x043\x02\0\x05\x12\x04\xfb\x01\x04\t\
    \n\r\n\x05\x043\x02\0\x01\x12\x04\xfb\x01\n\x13\n\r\n\x05\x043\x02\0\x03\
    \x12\x04\xfb\x01\x16\x17\n\x0c\n\x04\x043\x02\x01\x12\x04\xfc\x01\x04\
    \x19\n\x0f\n\x05\x043\x02\x01\x04\x12\x06\xfc\x01\x04\xfb\x01\x18\n\r\n\
    \x05\x043\x02\x01\x05\x12\x04\xfc\x01\x04\t\n\r\n\x05\x043\x02\x01\x01\
    \x12\x04\xfc\x01\n\x14\n\r\n\x05\x043\x02\x01\x03\x12\x04\xfc\x01\x17\
    \x18\n\x0c\n\x04\x043\x02\x02\x12\x04\xfd\x01\x04\x1f\n\x0f\n\x05\x043\
    \x02\x02\x04\x12\x06\xfd\x01\x04\xfc\x01\x19\n\r\n\x05\x043\x02\x02\x05\
    \x12\x04\xfd\x01\x04\t\n\r\n\x05\x043\x02\x02\x01\x12\x04\xfd\x01\n\x1a\
    \n\r\n\x05\x043\x02\x02\x03\x12\x04\xfd\x01\x1d\x1e\n\x0c\n\x02\x044\x12\
    \x06\x80\x02\0\x85\x02\x01\n\x0b\n\x03\x044\x01\x12\x04\x80\x02\x08\x1c\
    \n\x0c\n\x04\x044\x02\0\x12\x04\x81\x02\x04\x18\n\x0f\n\x05\x044\x02\0\
    \x04\x12\x06\x81\x02\x04\x80\x02\x1e\n\r\n\x05\x044\x02\0\x05\x12\x04\
    \x81\x02\x04\t\n\r\n\x05\x044\x02\0\x01\x12\x04\x81\x02\n\x13\n\r\n\x05\
    \x044\x02\0\x03\x12\x04\x81\x02\x16\x17\n\x0c\n\x04\x044\x02\x01\x12\x04\
    \x82\x02\x04\x19\n\x0f\n\x05\x044\x02\x01\x04\x12\x06\x82\x02\x04\x81\
    \x02\x18\n\r\n\x05\x044\x02\x01\x05\x12\x04\x82\x02\x04\t\n\r\n\x05\x044\
    \x02\x01\x01\x12\x04\x82\x02\n\x14\n\r\n\x05\x044\x02\x01\x03\x12\x04\
    \x82\x02\x17\x18\n\x0c\n\x04\x044\x02\x02\x12\x04\x83\x02\x04\x16\n\x0f\
    \n\x05\x044\x02\x02\x04\x12\x06\x83\x02\x04\x82\x02\x19\n\r\n\x05\x044\
    \x02\x02\x05\x12\x04\x83\x02\x04\t\n\r\n\x05\x044\x02\x02\x01\x12\x04\
    \x83\x02\n\x11\n\r\n\x05\x044\x02\x02\x03\x12\x04\x83\x02\x14\x15\n\x0c\
    \n\x04\x044\x02\x03\x12\x04\x84\x02\x044\n\x0f\n\x05\x044\x02\x03\x04\
    \x12\x06\x84\x02\x04\x83\x02\x16\n\r\n\x05\x044\x02\x03\x06\x12\x04\x84\
    \x02\x04\x1f\n\r\n\x05\x044\x02\x03\x01\x12\x04\x84\x02\x20/\n\r\n\x05\
    \x044\x02\x03\x03\x12\x04\x84\x0223\n\x0c\n\x02\x045\x12\x06\x87\x02\0\
    \x89\x02\x01\n\x0b\n\x03\x045\x01\x12\x04\x87\x02\x08\x1d\n\x0c\n\x04\
    \x045\x02\0\x12\x04\x88\x02\x04\x1e\n\x0f\n\x05\x045\x02\0\x04\x12\x06\
    \x88\x02\x04\x87\x02\x1f\n\r\n\x05\x045\x02\0\x05\x12\x04\x88\x02\x04\
    \x08\n\r\n\x05\x045\x02\0\x01\x12\x04\x88\x02\t\x19\n\r\n\x05\x045\x02\0\
    \x03\x12\x04\x88\x02\x1c\x1d\n\x0c\n\x02\x046\x12\x06\x8b\x02\0\x8d\x02\
    \x01\n\x0b\n\x03\x046\x01\x12\x04\x8b\x02\x08\x1c\n\x0c\n\x04\x046\x02\0\
    \x12\x04\x8c\x02\x04\x13\n\x0f\n\x05\x046\x02\0\x04\x12\x06\x8c\x02\x04\
    \x8b\x02\x1e\n\r\n\x05\x046\x02\0\x05\x12\x04\x8c\x02\x04\x08\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\x8c\x02\t\x0e\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \x8c\x02\x11\x12\n\x0c\n\x02\x047\x12\x06\x8f\x02\0\x91\x02\x01\n\x0b\n\
    \x03\x047\x01\x12\x04\x8f\x02\x08\x1d\n\x0c\n\x04\x047\x02\0\x12\x04\x90\
    \x02\x04\x15\n\x0f\n\x05\x047\x02\0\x04\x12\x06\x90\x02\x04\x8f\x02\x1f\
    \n\r\n\x05\x047\x02\0\x05\x12\x04\x90\x02\x04\n\n\r\n\x05\x047\x02\0\x01\
    \x12\x04\x90\x02\x0b\x10\n\r\n\x05\x047\x02\0\x03\x12\x04\x90\x02\x13\
    \x14\n\x0c\n\x02\x048\x12\x06\x93\x02\0\x97\x02\x01\n\x0b\n\x03\x048\x01\
    \x12\x04\x93\x02\x08\x1b\n\x0c\n\x04\x048\x02\0\x12\x04\x94\x02\x08\x1d\
    \n\x0f\n\x05\x048\x02\0\x04\x12\x06\x94\x02\x08\x93\x02\x1d\n\r\n\x05\
    \x048\x02\0\x05\x12\x04\x94\x02\x08\x0e\n\r\n\x05\x048\x02\0\x01\x12\x04\
    \x94\x02\x0f\x18\n\r\n\x05\x048\x02\0\x03\x12\x04\x94\x02\x1b\x1c\n\x0c\
    \n\x04\x048\x02\x01\x12\x04\x95\x02\x08\x1d\n\x0f\n\x05\x048\x02\x01\x04\
    \x12\x06\x95\x02\x08\x94\x02\x1d\n\r\n\x05\x048\x02\x01\x05\x12\x04\x95\
    \x02\x08\x0e\n\r\n\x05\x048\x02\x01\x01\x12\x04\x95\x02\x0f\x18\n\r\n\
    \x05\x048\x02\x01\x03\x12\x04\x95\x02\x1b\x1c\n\x0c\n\x04\x048\x02\x02\
    \x12\x04\x96\x02\x08\x18\n\x0f\n\x05\x048\x02\x02\x04\x12\x06\x96\x02\
    \x08\x95\x02\x1d\n\r\n\x05\x048\x02\x02\x05\x12\x04\x96\x02\x08\x0e\n\r\
    \n\x05\x048\x02\x02\x01\x12\x04\x96\x02\x0f\x13\n\r\n\x05\x048\x02\x02\
    \x03\x12\x04\x96\x02\x16\x17\n\x0c\n\x02\x049\x12\x06\x99\x02\0\x9c\x02\
    \x01\n\x0b\n\x03\x049\x01\x12\x04\x99\x02\x08\x1c\n\x0c\n\x04\x049\x02\0\
    \x12\x04\x9a\x02\x08\x20\n\x0f\n\x05\x049\x02\0\x04\x12\x06\x9a\x02\x08\
    \x99\x02\x1e\n\r\n\x05\x049\x02\0\x05\x12\x04\x9a\x02\x08\r\n\r\n\x05\
    \x049\x02\0\x01\x12\x04\x9a\x02\x0e\x1b\n\r\n\x05\x049\x02\0\x03\x12\x04\
    \x9a\x02\x1e\x1f\n\x0c\n\x04\x049\x02\x01\x12\x04\x9b\x02\x08\x1c\n\x0f\
    \n\x05\x049\x02\x01\x04\x12\x06\x9b\x02\x08\x9a\x02\x20\n\r\n\x05\x049\
    \x02\x01\x05\x12\x04\x9b\x02\x08\x0e\n\r\n\x05\x049\x02\x01\x01\x12\x04\
    \x9b\x02\x0f\x17\n\r\n\x05\x049\x02\x01\x03\x12\x04\x9b\x02\x1a\x1b\n\
    \x0c\n\x02\x04:\x12\x06\x9e\x02\0\xa2\x02\x01\n\x0b\n\x03\x04:\x01\x12\
    \x04\x9e\x02\x08\x20\n\x0c\n\x04\x04:\x02\0\x12\x04\x9f\x02\x08\x1c\n\
    \x0f\n\x05\x04:\x02\0\x04\x12\x06\x9f\x02\x08\x9e\x02\"\n\r\n\x05\x04:\
    \x02\0\x05\x12\x04\x9f\x02\x08\x0e\n\r\n\x05\x04:\x02\0\x01\x12\x04\x9f\
    \x02\x0f\x17\n\r\n\x05\x04:\x02\0\x03\x12\x04\x9f\x02\x1a\x1b\n\x0c\n\
    \x04\x04:\x02\x01\x12\x04\xa0\x02\x08\x1e\n\x0f\n\x05\x04:\x02\x01\x04\
    \x12\x06\xa0\x02\x08\x9f\x02\x1c\n\r\n\x05\x04:\x02\x01\x05\x12\x04\xa0\
    \x02\x08\r\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xa0\x02\x0e\x19\n\r\n\x05\
    \x04:\x02\x01\x03\x12\x04\xa0\x02\x1c\x1d\n\x0c\n\x04\x04:\x02\x02\x12\
    \x04\xa1\x02\x08(\n\x0f\n\x05\x04:\x02\x02\x04\x12\x06\xa1\x02\x08\xa0\
    \x02\x1e\n\r\n\x05\x04:\x02\x02\x05\x12\x04\xa1\x02\x08\r\n\r\n\x05\x04:\
    \x02\x02\x01\x12\x04\xa1\x02\x0e#\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xa1\
    \x02&'\n\x0c\n\x02\x04;\x12\x06\xa4\x02\0\xa6\x02\x01\n\x0b\n\x03\x04;\
    \x01\x12\x04\xa4\x02\x08!\n\x0c\n\x04\x04;\x02\0\x12\x04\xa5\x02\x08\x20\
    \n\x0f\n\x05\x04;\x02\0\x04\x12\x06\xa5\x02\x08\xa4\x02#\n\r\n\x05\x04;\
    \x02\0\x05\x12\x04\xa5\x02\x08\r\n\r\n\x05\x04;\x02\0\x01\x12\x04\xa5\
    \x02\x0e\x1b\n\r\n\x05\x04;\x02\0\x03\x12\x04\xa5\x02\x1e\x1f\n\x0c\n\
    \x02\x04<\x12\x06\xa8\x02\0\xab\x02\x01\n\x0b\n\x03\x04<\x01\x12\x04\xa8\
    \x02\x08\x19\n\x0c\n\x04\x04<\x02\0\x12\x04\xa9\x02\x08\x1a\n\x0f\n\x05\
    \x04<\x02\0\x04\x12\x06\xa9\x02\x08\xa8\x02\x1b\n\r\n\x05\x04<\x02\0\x05\
    \x12\x04\xa9\x02\x08\r\n\r\n\x05\x04<\x02\0\x01\x12\x04\xa9\x02\x0e\x15\
    \n\r\n\x05\x04<\x02\0\x03\x12\x04\xa9\x02\x18\x19\n\x0c\n\x04\x04<\x02\
    \x01\x12\x04\xaa\x02\x08\x1d\n\x0f\n\x05\x04<\x02\x01\x04\x12\x06\xaa\
    \x02\x08\xa9\x02\x1a\n\r\n\x05\x04<\x02\x01\x05\x12\x04\xaa\x02\x08\r\n\
    \r\n\x05\x04<\x02\x01\x01\x12\x04\xaa\x02\x0e\x18\n\r\n\x05\x04<\x02\x01\
    \x03\x12\x04\xaa\x02\x1b\x1c\n\x0c\n\x02\x04=\x12\x06\xad\x02\0\xaf\x02\
    \x01\n\x0b\n\x03\x04=\x01\x12\x04\xad\x02\x08\x1a\n\x0c\n\x04\x04=\x02\0\
    \x12\x04\xae\x02\x08!\n\x0f\n\x05\x04=\x02\0\x04\x12\x06\xae\x02\x08\xad\
    \x02\x1c\n\r\n\x05\x04=\x02\0\x05\x12\x04\xae\x02\x08\x0e\n\r\n\x05\x04=\
    \x02\0\x01\x12\x04\xae\x02\x0f\x1c\n\r\n\x05\x04=\x02\0\x03\x12\x04\xae\
    \x02\x1f\x20\n\n\n\x02\x04>\x12\x04\xb1\x02\0\x1f\n\x0b\n\x03\x04>\x01\
    \x12\x04\xb1\x02\x08\x1b\n\x0c\n\x02\x04?\x12\x06\xb3\x02\0\xb5\x02\x01\
    \n\x0b\n\x03\x04?\x01\x12\x04\xb3\x02\x08\x1c\n\x0c\n\x04\x04?\x02\0\x12\
    \x04\xb4\x02\x08\x1d\n\x0f\n\x05\x04?\x02\0\x04\x12\x06\xb4\x02\x08\xb3\
    \x02\x1e\n\r\n\x05\x04?\x02\0\x05\x12\x04\xb4\x02\x08\r\n\r\n\x05\x04?\
    \x02\0\x01\x12\x04\xb4\x02\x0e\x18\n\r\n\x05\x04?\x02\0\x03\x12\x04\xb4\
    \x02\x1b\x1c\n\x0c\n\x02\x04@\x12\x06\xb7\x02\0\xb9\x02\x01\n\x0b\n\x03\
    \x04@\x01\x12\x04\xb7\x02\x08\x1d\n\x0c\n\x04\x04@\x02\0\x12\x04\xb8\x02\
    \x08\x1c\n\x0f\n\x05\x04@\x02\0\x04\x12\x06\xb8\x02\x08\xb7\x02\x1f\n\r\
    \n\x05\x04@\x02\0\x05\x12\x04\xb8\x02\x08\x0e\n\r\n\x05\x04@\x02\0\x01\
    \x12\x04\xb8\x02\x0f\x17\n\r\n\x05\x04@\x02\0\x03\x12\x04\xb8\x02\x1a\
    \x1b\n\x0c\n\x02\x04A\x12\x06\xbb\x02\0\xbe\x02\x01\n\x0b\n\x03\x04A\x01\
    \x12\x04\xbb\x02\x08\x1e\n\x0c\n\x04\x04A\x02\0\x12\x04\xbc\x02\x08\x1d\
    \n\x0f\n\x05\x04A\x02\0\x04\x12\x06\xbc\x02\x08\xbb\x02\x20\n\r\n\x05\
    \x04A\x02\0\x05\x12\x04\xbc\x02\x08\x0e\n\r\n\x05\x04A\x02\0\x01\x12\x04\
    \xbc\x02\x0f\x18\n\r\n\x05\x04A\x02\0\x03\x12\x04\xbc\x02\x1b\x1c\n\x0c\
    \n\x04\x04A\x02\x01\x12\x04\xbd\x02\x08\x20\n\x0f\n\x05\x04A\x02\x01\x04\
    \x12\x06\xbd\x02\x08\xbc\x02\x1d\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xbd\
    \x02\x08\r\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xbd\x02\x0e\x1b\n\r\n\x05\
    \x04A\x02\x01\x03\x12\x04\xbd\x02\x1e\x1f\n\x0c\n\x02\x04B\x12\x06\xc0\
    \x02\0\xc2\x02\x01\n\x0b\n\x03\x04B\x01\x12\x04\xc0\x02\x08\x20\n\x0c\n\
    \x04\x04B\x02\0\x12\x04\xc1\x02\x04\x1b\n\x0f\n\x05\x04B\x02\0\x04\x12\
    \x06\xc1\x02\x04\xc0\x02\"\n\r\n\x05\x04B\x02\0\x05\x12\x04\xc1\x02\x04\
    \n\n\r\n\x05\x04B\x02\0\x01\x12\x04\xc1\x02\x0b\x16\n\r\n\x05\x04B\x02\0\
    \x03\x12\x04\xc1\x02\x19\x1a\n\x0c\n\x02\x04C\x12\x06\xc4\x02\0\xc6\x02\
    \x01\n\x0b\n\x03\x04C\x01\x12\x04\xc4\x02\x08!\n\x0c\n\x04\x04C\x02\0\
    \x12\x04\xc5\x02\x04\x13\n\x0f\n\x05\x04C\x02\0\x04\x12\x06\xc5\x02\x04\
    \xc4\x02#\n\r\n\x05\x04C\x02\0\x05\x12\x04\xc5\x02\x04\x08\n\r\n\x05\x04\
    C\x02\0\x01\x12\x04\xc5\x02\t\x0e\n\r\n\x05\x04C\x02\0\x03\x12\x04\xc5\
    \x02\x11\x12b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
