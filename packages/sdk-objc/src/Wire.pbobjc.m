// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Wire.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Wire.pbobjc.h"
#import "Cryptography.pbobjc.h"
#import "Peer.pbobjc.h"
#import "Transaction.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - WireRoot

@implementation WireRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - WireRoot_FileDescriptor

static GPBFileDescriptor *WireRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"Catalyst.Protocol.Wire"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - ProtocolErrorMessage

@implementation ProtocolErrorMessage

@dynamic hasSignature, signature;
@dynamic hasPeerId, peerId;
@dynamic correlationId;
@dynamic code;

typedef struct ProtocolErrorMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t code;
  Signature *signature;
  PeerId *peerId;
  NSData *correlationId;
} ProtocolErrorMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = ProtocolErrorMessage_FieldNumber_Signature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProtocolErrorMessage__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "peerId",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerId),
        .number = ProtocolErrorMessage_FieldNumber_PeerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProtocolErrorMessage__storage_, peerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "correlationId",
        .dataTypeSpecific.className = NULL,
        .number = ProtocolErrorMessage_FieldNumber_CorrelationId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProtocolErrorMessage__storage_, correlationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = ProtocolErrorMessage_FieldNumber_Code,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProtocolErrorMessage__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProtocolErrorMessage class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProtocolErrorMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProtocolMessage

@implementation ProtocolMessage

@dynamic hasPeerId, peerId;
@dynamic correlationId;
@dynamic typeURL;
@dynamic value;
@dynamic hasSignature, signature;

typedef struct ProtocolMessage__storage_ {
  uint32_t _has_storage_[1];
  PeerId *peerId;
  NSData *correlationId;
  NSString *typeURL;
  NSData *value;
  Signature *signature;
} ProtocolMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "peerId",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerId),
        .number = ProtocolMessage_FieldNumber_PeerId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProtocolMessage__storage_, peerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "correlationId",
        .dataTypeSpecific.className = NULL,
        .number = ProtocolMessage_FieldNumber_CorrelationId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ProtocolMessage__storage_, correlationId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "typeURL",
        .dataTypeSpecific.className = NULL,
        .number = ProtocolMessage_FieldNumber_TypeURL,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ProtocolMessage__storage_, typeURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ProtocolMessage_FieldNumber_Value,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ProtocolMessage__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = GPBStringifySymbol(Signature),
        .number = ProtocolMessage_FieldNumber_Signature,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ProtocolMessage__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProtocolMessage class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProtocolMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\004\241!!\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionBroadcast

@implementation TransactionBroadcast

@dynamic hasPublicEntry, publicEntry;

typedef struct TransactionBroadcast__storage_ {
  uint32_t _has_storage_[1];
  PublicEntry *publicEntry;
} TransactionBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "publicEntry",
        .dataTypeSpecific.className = GPBStringifySymbol(PublicEntry),
        .number = TransactionBroadcast_FieldNumber_PublicEntry,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionBroadcast__storage_, publicEntry),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionBroadcast class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - CandidateDeltaBroadcast

@implementation CandidateDeltaBroadcast

@dynamic hash_p;
@dynamic hasProducerId, producerId;
@dynamic previousDeltaDfsHash;

typedef struct CandidateDeltaBroadcast__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  PeerId *producerId;
  NSData *previousDeltaDfsHash;
} CandidateDeltaBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = CandidateDeltaBroadcast_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(CandidateDeltaBroadcast__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "producerId",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerId),
        .number = CandidateDeltaBroadcast_FieldNumber_ProducerId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(CandidateDeltaBroadcast__storage_, producerId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "previousDeltaDfsHash",
        .dataTypeSpecific.className = NULL,
        .number = CandidateDeltaBroadcast_FieldNumber_PreviousDeltaDfsHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(CandidateDeltaBroadcast__storage_, previousDeltaDfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[CandidateDeltaBroadcast class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(CandidateDeltaBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - FavouriteDeltaBroadcast

@implementation FavouriteDeltaBroadcast

@dynamic hasCandidate, candidate;
@dynamic hasVoterId, voterId;

typedef struct FavouriteDeltaBroadcast__storage_ {
  uint32_t _has_storage_[1];
  CandidateDeltaBroadcast *candidate;
  PeerId *voterId;
} FavouriteDeltaBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "candidate",
        .dataTypeSpecific.className = GPBStringifySymbol(CandidateDeltaBroadcast),
        .number = FavouriteDeltaBroadcast_FieldNumber_Candidate,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(FavouriteDeltaBroadcast__storage_, candidate),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "voterId",
        .dataTypeSpecific.className = GPBStringifySymbol(PeerId),
        .number = FavouriteDeltaBroadcast_FieldNumber_VoterId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(FavouriteDeltaBroadcast__storage_, voterId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[FavouriteDeltaBroadcast class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(FavouriteDeltaBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DeltaDfsHashBroadcast

@implementation DeltaDfsHashBroadcast

@dynamic deltaDfsHash;
@dynamic previousDeltaDfsHash;

typedef struct DeltaDfsHashBroadcast__storage_ {
  uint32_t _has_storage_[1];
  NSData *deltaDfsHash;
  NSData *previousDeltaDfsHash;
} DeltaDfsHashBroadcast__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "deltaDfsHash",
        .dataTypeSpecific.className = NULL,
        .number = DeltaDfsHashBroadcast_FieldNumber_DeltaDfsHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeltaDfsHashBroadcast__storage_, deltaDfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "previousDeltaDfsHash",
        .dataTypeSpecific.className = NULL,
        .number = DeltaDfsHashBroadcast_FieldNumber_PreviousDeltaDfsHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeltaDfsHashBroadcast__storage_, previousDeltaDfsHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeltaDfsHashBroadcast class]
                                     rootClass:[WireRoot class]
                                          file:WireRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeltaDfsHashBroadcast__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
