// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Cryptography.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers.h>
#else
 #import "GPBProtocolBuffers.h"
#endif

#if GOOGLE_PROTOBUF_OBJC_VERSION < 30002
#error This file was generated by a newer version of protoc which is incompatible with your Protocol Buffer library sources.
#endif
#if 30002 < GOOGLE_PROTOBUF_OBJC_MIN_SUPPORTED_VERSION
#error This file was generated by an older version of protoc which is incompatible with your Protocol Buffer library sources.
#endif

// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

CF_EXTERN_C_BEGIN

@class SigningContext;
GPB_ENUM_FWD_DECLARE(NetworkType);

NS_ASSUME_NONNULL_BEGIN

#pragma mark - Enum SignatureType

/** Represents domains of a node. */
typedef GPB_ENUM(SignatureType) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  SignatureType_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown signature. */
  SignatureType_SignatureTypeUnknown = 0,

  /** Signatures for public transactions. */
  SignatureType_TransactionPublic = 1,

  /** Signatures for confidential transactions. */
  SignatureType_TransactionConfidential = 2,

  /** Signatures for rpc messages. */
  SignatureType_ProtocolRpc = 3,

  /** Signatures for peer protocol messages. */
  SignatureType_ProtocolPeer = 4,
};

GPBEnumDescriptor *SignatureType_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL SignatureType_IsValidValue(int32_t value);

#pragma mark - Enum ErrorCode

typedef GPB_ENUM(ErrorCode) {
  /**
   * Value used if any message's field encounters a value that is not defined
   * by this enum. The message will also have C functions to get/set the rawValue
   * of the field.
   **/
  ErrorCode_GPBUnrecognizedEnumeratorValue = kGPBUnrecognizedEnumeratorValue,
  /** Unknown error. */
  ErrorCode_ErrorCodeUnknown = 0,

  /** Signature is of incorrect length or does not correspond to a valid point. */
  ErrorCode_InvalidSignature = 1,

  /** Public key is of incorrect length or cannot be decompressed to a valid point. */
  ErrorCode_InvalidPublicKey = 2,

  /** Private key is of incorrect length. */
  ErrorCode_InvalidPrivateKey = 3,

  /** Signature cannot be verified against the provided information. */
  ErrorCode_SignatureVerificationFailure = 4,

  /** Context exceed the maximum allowed length. */
  ErrorCode_InvalidContextLength = 5,

  /** Unable to convert message to valid data. */
  ErrorCode_InvalidBatchMessage = 6,

  /** Cannot perform batch verification as an unequal number of messages/signatures/keys were provided. */
  ErrorCode_ArraysNotEqualLength = 7,

  /** One or more signatures cannot be verified. */
  ErrorCode_BatchVerificationFailure = 8,

  /** No error (just a teapot). */
  ErrorCode_NoError = 418,
};

GPBEnumDescriptor *ErrorCode_EnumDescriptor(void);

/**
 * Checks to see if the given value is defined by the enum or was not known at
 * the time this source was generated.
 **/
BOOL ErrorCode_IsValidValue(int32_t value);

#pragma mark - CryptographyRoot

/**
 * Exposes the extension registry for this file.
 *
 * The base class provides:
 * @code
 *   + (GPBExtensionRegistry *)extensionRegistry;
 * @endcode
 * which is a @c GPBExtensionRegistry that includes all the extensions defined by
 * this file and all files that it depends on.
 **/
@interface CryptographyRoot : GPBRootObject
@end

#pragma mark - Signature

typedef GPB_ENUM(Signature_FieldNumber) {
  Signature_FieldNumber_SigningContext = 1,
  Signature_FieldNumber_RawBytes = 2,
};

@interface Signature : GPBMessage

/** system domain context. */
@property(nonatomic, readwrite, strong, null_resettable) SigningContext *signingContext;
/** Test to see if @c signingContext has been set. */
@property(nonatomic, readwrite) BOOL hasSigningContext;

/** signature digest. */
@property(nonatomic, readwrite, copy, null_resettable) NSData *rawBytes;

@end

#pragma mark - SigningContext

typedef GPB_ENUM(SigningContext_FieldNumber) {
  SigningContext_FieldNumber_NetworkType = 1,
  SigningContext_FieldNumber_SignatureType = 2,
};

@interface SigningContext : GPBMessage

/** is the network enum (mainet / devnet etc). */
@property(nonatomic, readwrite) enum NetworkType networkType;

/** contains info on whether the signature is for a protocol message or a transaction. */
@property(nonatomic, readwrite) SignatureType signatureType;

@end

/**
 * Fetches the raw value of a @c SigningContext's @c networkType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t SigningContext_NetworkType_RawValue(SigningContext *message);
/**
 * Sets the raw value of an @c SigningContext's @c networkType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetSigningContext_NetworkType_RawValue(SigningContext *message, int32_t value);

/**
 * Fetches the raw value of a @c SigningContext's @c signatureType property, even
 * if the value was not defined by the enum at the time the code was generated.
 **/
int32_t SigningContext_SignatureType_RawValue(SigningContext *message);
/**
 * Sets the raw value of an @c SigningContext's @c signatureType property, allowing
 * it to be set to a value that was not defined by the enum at the time the code
 * was generated.
 **/
void SetSigningContext_SignatureType_RawValue(SigningContext *message, int32_t value);

#pragma mark - SignatureBatch

typedef GPB_ENUM(SignatureBatch_FieldNumber) {
  SignatureBatch_FieldNumber_SignaturesArray = 1,
  SignatureBatch_FieldNumber_PublicKeysArray = 2,
  SignatureBatch_FieldNumber_MessagesArray = 3,
  SignatureBatch_FieldNumber_Context = 4,
};

/**
 * Holds data for batch verification of signatures.
 **/
@interface SignatureBatch : GPBMessage

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *signaturesArray;
/** The number of items in @c signaturesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger signaturesArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *publicKeysArray;
/** The number of items in @c publicKeysArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger publicKeysArray_Count;

@property(nonatomic, readwrite, strong, null_resettable) NSMutableArray<NSData*> *messagesArray;
/** The number of items in @c messagesArray without causing the array to be created. */
@property(nonatomic, readonly) NSUInteger messagesArray_Count;

@property(nonatomic, readwrite, copy, null_resettable) NSData *context;

@end

NS_ASSUME_NONNULL_END

CF_EXTERN_C_END

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
